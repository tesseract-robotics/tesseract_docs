<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tesseract: tesseract_common Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../custom.css" rel="stylesheet" type="text/css"/>
<link href="../../custom_dark_theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Tesseract
   </div>
   <div id="projectbrief">Motion Planning Environment</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">tesseract_common Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:d0/def/namespacetesseract__common_1_1detail__any"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/def/namespacetesseract__common_1_1detail__any.html">detail_any</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d1/d92/namespacetesseract__common_1_1serialization"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d92/namespacetesseract__common_1_1serialization.html">serialization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d4e/classtesseract__common_1_1AllowedCollisionMatrix.html">AllowedCollisionMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d48/structtesseract__common_1_1ambiguate.html">ambiguate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d58/structtesseract__common_1_1AnyPoly.html">AnyPoly</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dca/classtesseract__common_1_1BytesResource.html">BytesResource</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d32/structtesseract__common_1_1CalibrationInfo.html">CalibrationInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d6/d32/structtesseract__common_1_1CalibrationInfo.html" title="The CalibrationInfo struct.">CalibrationInfo</a> struct.  <a href="../../d6/d32/structtesseract__common_1_1CalibrationInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d3b/structtesseract__common_1_1ClassLoader.html">ClassLoader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a wrapper around Boost DLL for loading plugins within Tesseract.  <a href="../../d7/d3b/structtesseract__common_1_1ClassLoader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d29/classtesseract__common_1_1CloneCache.html">CloneCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to create a cache of objects.  <a href="../../db/d29/classtesseract__common_1_1CloneCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dc7/classtesseract__common_1_1CollisionMarginData.html">CollisionMarginData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores information about how the margins allowed between collision objects.  <a href="../../d6/dc7/classtesseract__common_1_1CollisionMarginData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/structtesseract__common_1_1ContactManagersPluginInfo.html">ContactManagersPluginInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contact managers plugin information structure.  <a href="../../db/d9a/structtesseract__common_1_1ContactManagersPluginInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dd7/classtesseract__common_1_1GeneralResourceLocator.html">GeneralResourceLocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A general resource loaders using environment variable.  <a href="../../d2/dd7/classtesseract__common_1_1GeneralResourceLocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d65/structtesseract__common_1_1got__type.html">got_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d31/structtesseract__common_1_1got__type_3_01A_01_4.html">got_type&lt; A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d18/structtesseract__common_1_1has__member.html">has_member</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df6/classtesseract__common_1_1JointState.html">JointState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d05/classtesseract__common_1_1JointTrajectory.html">JointTrajectory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a joint trajectory.  <a href="../../da/d05/classtesseract__common_1_1JointTrajectory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d94/structtesseract__common_1_1KinematicLimits.html">KinematicLimits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store kinematic limits.  <a href="../../d2/d94/structtesseract__common_1_1KinematicLimits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d63/structtesseract__common_1_1KinematicsPluginInfo.html">KinematicsPluginInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The kinematics plugin information structure.  <a href="../../d0/d63/structtesseract__common_1_1KinematicsPluginInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d31/structtesseract__common_1_1ManipulatorInfo.html">ManipulatorInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains information about a robot manipulator.  <a href="../../d4/d31/structtesseract__common_1_1ManipulatorInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de0/structtesseract__common_1_1PairHash.html">PairHash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d88/structtesseract__common_1_1PluginInfo.html">PluginInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Plugin Information struct.  <a href="../../d8/d88/structtesseract__common_1_1PluginInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d89/structtesseract__common_1_1PluginInfoContainer.html">PluginInfoContainer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da5/classtesseract__common_1_1PluginLoader.html">PluginLoader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a utility class for loading plugins within Tesseract.  <a href="../../d1/da5/classtesseract__common_1_1PluginLoader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/def/classtesseract__common_1_1Resource.html">Resource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents resource data available from a file or url.  <a href="../../d8/def/classtesseract__common_1_1Resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de6/classtesseract__common_1_1ResourceLocator.html">ResourceLocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for resource loaders.  <a href="../../d0/de6/classtesseract__common_1_1ResourceLocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dc2/structtesseract__common_1_1Serialization.html">Serialization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dfa/structtesseract__common_1_1sig__check.html">sig_check</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d85/classtesseract__common_1_1SimpleLocatedResource.html">SimpleLocatedResource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d8/def/classtesseract__common_1_1Resource.html" title="Represents resource data available from a file or url.">Resource</a> implementation for a local file.  <a href="../../d6/d85/classtesseract__common_1_1SimpleLocatedResource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dbc/structtesseract__common_1_1TaskComposerPluginInfo.html">TaskComposerPluginInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The task composer plugin information structure.  <a href="../../db/dbc/structtesseract__common_1_1TaskComposerPluginInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6a/classtesseract__common_1_1TesseractSupportResourceLocator.html">TesseractSupportResourceLocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for resource loaders.  <a href="../../d9/d6a/classtesseract__common_1_1TesseractSupportResourceLocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d81/classtesseract__common_1_1TestPluginBase.html">TestPluginBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dd9/classtesseract__common_1_1TestPluginMultiply.html">TestPluginMultiply</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/df7/classtesseract__common_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple timer class leveraging chrono high resolution clock.  <a href="../../d7/df7/classtesseract__common_1_1Timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d36/structtesseract__common_1_1TypeErasureBase.html">TypeErasureBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1f/structtesseract__common_1_1TypeErasureInstance.html">TypeErasureInstance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df3/structtesseract__common_1_1TypeErasureInstanceWrapper.html">TypeErasureInstanceWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dd5/structtesseract__common_1_1TypeErasureInterface.html">TypeErasureInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the interface that all type erasures interfaces must inherit from.  <a href="../../d6/dd5/structtesseract__common_1_1TypeErasureInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a79d2a34647d0da5e574629878c142086"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a79d2a34647d0da5e574629878c142086">AllowedCollisionEntries</a> = std::unordered_map&lt; <a class="el" href="../../df/da9/namespacetesseract__common.html#a5b28b7ae665b374a7ca166d496f648ce">tesseract_common::LinkNamesPair</a>, std::string, <a class="el" href="../../d7/de0/structtesseract__common_1_1PairHash.html">tesseract_common::PairHash</a> &gt;</td></tr>
<tr class="separator:a79d2a34647d0da5e574629878c142086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0272abd157d81a79f04aad1a6ddd01"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a5b0272abd157d81a79f04aad1a6ddd01">AnyPolyBase</a> = <a class="el" href="../../de/d36/structtesseract__common_1_1TypeErasureBase.html">tesseract_common::TypeErasureBase</a>&lt; <a class="el" href="../../d6/dd5/structtesseract__common_1_1TypeErasureInterface.html">TypeErasureInterface</a>, <a class="el" href="../../d1/dd5/structtesseract__common_1_1detail__any_1_1AnyInstance.html">detail_any::AnyInstance</a> &gt;</td></tr>
<tr class="separator:a5b0272abd157d81a79f04aad1a6ddd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84cc21cc4b384291adbbddaa81fe6447"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a84cc21cc4b384291adbbddaa81fe6447">PairsCollisionMarginData</a> = std::unordered_map&lt; <a class="el" href="../../df/da9/namespacetesseract__common.html#a5b28b7ae665b374a7ca166d496f648ce">tesseract_common::LinkNamesPair</a>, double, <a class="el" href="../../d7/de0/structtesseract__common_1_1PairHash.html">tesseract_common::PairHash</a> &gt;</td></tr>
<tr class="separator:a84cc21cc4b384291adbbddaa81fe6447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef4ec89c4c07fc0a75c4bc24da9681c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a2ef4ec89c4c07fc0a75c4bc24da9681c">SimpleResourceLocatorFn</a> = std::function&lt; std::string(const std::string &amp;)&gt;</td></tr>
<tr class="separator:a2ef4ec89c4c07fc0a75c4bc24da9681c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000d15c3ab8d8ba4ebdaae64153b053a"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &gt; </td></tr>
<tr class="memitem:a000d15c3ab8d8ba4ebdaae64153b053a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a000d15c3ab8d8ba4ebdaae64153b053a">AlignedVector</a> = std::vector&lt; <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a>, Eigen::aligned_allocator&lt; <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &gt; &gt;</td></tr>
<tr class="memdesc:a000d15c3ab8d8ba4ebdaae64153b053a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable easy switching to std::filesystem when available.  <a href="../../df/da9/namespacetesseract__common.html#a000d15c3ab8d8ba4ebdaae64153b053a">More...</a><br /></td></tr>
<tr class="separator:a000d15c3ab8d8ba4ebdaae64153b053a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5a4b6149060671cf8c3f9d15ef58c4"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a2c5a4b6149060671cf8c3f9d15ef58c4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a2c5a4b6149060671cf8c3f9d15ef58c4">AlignedMap</a> = std::map&lt; Key, Value, std::less&lt; Key &gt;, Eigen::aligned_allocator&lt; std::pair&lt; const Key, Value &gt; &gt; &gt;</td></tr>
<tr class="separator:a2c5a4b6149060671cf8c3f9d15ef58c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a5c73ede3e67335c3e09f9f3bc33a3"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a85a5c73ede3e67335c3e09f9f3bc33a3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a85a5c73ede3e67335c3e09f9f3bc33a3">AlignedUnorderedMap</a> = std::unordered_map&lt; Key, Value, std::hash&lt; Key &gt;, std::equal_to&lt; Key &gt;, Eigen::aligned_allocator&lt; std::pair&lt; const Key, Value &gt; &gt; &gt;</td></tr>
<tr class="separator:a85a5c73ede3e67335c3e09f9f3bc33a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d9921fc7ed323609ac57d06f939cb6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a94d9921fc7ed323609ac57d06f939cb6">VectorIsometry3d</a> = <a class="el" href="../../df/da9/namespacetesseract__common.html#a000d15c3ab8d8ba4ebdaae64153b053a">AlignedVector</a>&lt; Eigen::Isometry3d &gt;</td></tr>
<tr class="separator:a94d9921fc7ed323609ac57d06f939cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f208ea8b9c62f41c593647319d56f37"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a7f208ea8b9c62f41c593647319d56f37">VectorVector4d</a> = <a class="el" href="../../df/da9/namespacetesseract__common.html#a000d15c3ab8d8ba4ebdaae64153b053a">AlignedVector</a>&lt; Eigen::Vector4d &gt;</td></tr>
<tr class="separator:a7f208ea8b9c62f41c593647319d56f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89ed6517f4c84bdb2b037bb40f7d9d9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#af89ed6517f4c84bdb2b037bb40f7d9d9">VectorVector3d</a> = std::vector&lt; Eigen::Vector3d &gt;</td></tr>
<tr class="separator:af89ed6517f4c84bdb2b037bb40f7d9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60e1af30f961fc086b69e330c6434d4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#ac60e1af30f961fc086b69e330c6434d4">VectorVector2d</a> = <a class="el" href="../../df/da9/namespacetesseract__common.html#a000d15c3ab8d8ba4ebdaae64153b053a">AlignedVector</a>&lt; Eigen::Vector2d &gt;</td></tr>
<tr class="separator:ac60e1af30f961fc086b69e330c6434d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67bde3cb7bb235f0f61c370ef8bc74d8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a67bde3cb7bb235f0f61c370ef8bc74d8">TransformMap</a> = <a class="el" href="../../df/da9/namespacetesseract__common.html#a2c5a4b6149060671cf8c3f9d15ef58c4">AlignedMap</a>&lt; std::string, Eigen::Isometry3d &gt;</td></tr>
<tr class="separator:a67bde3cb7bb235f0f61c370ef8bc74d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917718f518f98714fce17e831ec1ea11"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a917718f518f98714fce17e831ec1ea11">Toolpath</a> = <a class="el" href="../../df/da9/namespacetesseract__common.html#a000d15c3ab8d8ba4ebdaae64153b053a">AlignedVector</a>&lt; <a class="el" href="../../df/da9/namespacetesseract__common.html#a94d9921fc7ed323609ac57d06f939cb6">VectorIsometry3d</a> &gt;</td></tr>
<tr class="separator:a917718f518f98714fce17e831ec1ea11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431ff65777ee0bed71e7671390638244"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a431ff65777ee0bed71e7671390638244">TrajArray</a> = Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:a431ff65777ee0bed71e7671390638244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b28b7ae665b374a7ca166d496f648ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a5b28b7ae665b374a7ca166d496f648ce">LinkNamesPair</a> = std::pair&lt; std::string, std::string &gt;</td></tr>
<tr class="separator:a5b28b7ae665b374a7ca166d496f648ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d1f6e0418164a6db0e1c447150340e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a43d1f6e0418164a6db0e1c447150340e">PluginInfoMap</a> = std::map&lt; std::string, <a class="el" href="../../d8/d88/structtesseract__common_1_1PluginInfo.html">PluginInfo</a> &gt;</td></tr>
<tr class="memdesc:a43d1f6e0418164a6db0e1c447150340e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map of <a class="el" href="../../d8/d88/structtesseract__common_1_1PluginInfo.html" title="The Plugin Information struct.">PluginInfo</a> to user defined name.  <a href="../../df/da9/namespacetesseract__common.html#a43d1f6e0418164a6db0e1c447150340e">More...</a><br /></td></tr>
<tr class="separator:a43d1f6e0418164a6db0e1c447150340e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af06d85d024a36d63b58a6031556af8a1"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#af06d85d024a36d63b58a6031556af8a1">CollisionMarginOverrideType</a> { <br />
&#160;&#160;<a class="el" href="../../df/da9/namespacetesseract__common.html#af06d85d024a36d63b58a6031556af8a1ab50339a10e1de285ac99d4c3990b8693">NONE</a>
, <a class="el" href="../../df/da9/namespacetesseract__common.html#af06d85d024a36d63b58a6031556af8a1a560a2dd6f6744646473b3b19e1fe96d7">REPLACE</a>
, <a class="el" href="../../df/da9/namespacetesseract__common.html#af06d85d024a36d63b58a6031556af8a1ab9f20f7748e2e578e81ea9ae1a0dfb30">MODIFY</a>
, <a class="el" href="../../df/da9/namespacetesseract__common.html#af06d85d024a36d63b58a6031556af8a1a68f2f4f7ee420d8895a41ac3f35db3fe">OVERRIDE_DEFAULT_MARGIN</a>
, <br />
&#160;&#160;<a class="el" href="../../df/da9/namespacetesseract__common.html#af06d85d024a36d63b58a6031556af8a1ae54086ed48f7d2ca425bdeca2121c83c">OVERRIDE_PAIR_MARGIN</a>
, <a class="el" href="../../df/da9/namespacetesseract__common.html#af06d85d024a36d63b58a6031556af8a1a8f7ea9e9137c5d7d8bc6ea025484f55a">MODIFY_PAIR_MARGIN</a>
<br />
 }</td></tr>
<tr class="memdesc:af06d85d024a36d63b58a6031556af8a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies how the provided contact margin data should be applied.  <a href="../../df/da9/namespacetesseract__common.html#af06d85d024a36d63b58a6031556af8a1">More...</a><br /></td></tr>
<tr class="separator:af06d85d024a36d63b58a6031556af8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0808e2d3c913c41e852ab3819eadd828"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a0808e2d3c913c41e852ab3819eadd828">operator==</a> (const <a class="el" href="../../df/da9/namespacetesseract__common.html#a79d2a34647d0da5e574629878c142086">AllowedCollisionEntries</a> &amp;entries_1, const <a class="el" href="../../df/da9/namespacetesseract__common.html#a79d2a34647d0da5e574629878c142086">AllowedCollisionEntries</a> &amp;entries_2)</td></tr>
<tr class="separator:a0808e2d3c913c41e852ab3819eadd828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc465537e94a07d22996dd2708f6084"><td class="memTemplParams" colspan="2">template&lt;typename FloatType &gt; </td></tr>
<tr class="memitem:a6cc465537e94a07d22996dd2708f6084"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a6cc465537e94a07d22996dd2708f6084">isWithinPositionLimits</a> (const Eigen::Ref&lt; const Eigen::Matrix&lt; FloatType, Eigen::Dynamic, 1 &gt; &gt; &amp;joint_positions, const Eigen::Ref&lt; const Eigen::Matrix&lt; FloatType, Eigen::Dynamic, 2 &gt; &gt; &amp;position_limits)</td></tr>
<tr class="memdesc:a6cc465537e94a07d22996dd2708f6084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if within position limits.  <a href="../../df/da9/namespacetesseract__common.html#a6cc465537e94a07d22996dd2708f6084">More...</a><br /></td></tr>
<tr class="separator:a6cc465537e94a07d22996dd2708f6084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538003ce5c67e13e56fd7decc0fd7585"><td class="memTemplParams" colspan="2">template&lt;typename FloatType &gt; </td></tr>
<tr class="memitem:a538003ce5c67e13e56fd7decc0fd7585"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a538003ce5c67e13e56fd7decc0fd7585">satisfiesPositionLimits</a> (const Eigen::Ref&lt; const Eigen::Matrix&lt; FloatType, Eigen::Dynamic, 1 &gt; &gt; &amp;joint_positions, const Eigen::Ref&lt; const Eigen::Matrix&lt; FloatType, Eigen::Dynamic, 2 &gt; &gt; &amp;position_limits, const Eigen::Ref&lt; const Eigen::Matrix&lt; FloatType, Eigen::Dynamic, 1 &gt; &gt; &amp;max_diff, const Eigen::Ref&lt; const Eigen::Matrix&lt; FloatType, Eigen::Dynamic, 1 &gt; &gt; &amp;max_rel_diff)</td></tr>
<tr class="memdesc:a538003ce5c67e13e56fd7decc0fd7585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if joint position is within bounds or relatively equal to a limit.  <a href="../../df/da9/namespacetesseract__common.html#a538003ce5c67e13e56fd7decc0fd7585">More...</a><br /></td></tr>
<tr class="separator:a538003ce5c67e13e56fd7decc0fd7585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad966f78ba21ac22b33b036d94958ff82"><td class="memTemplParams" colspan="2">template&lt;typename FloatType &gt; </td></tr>
<tr class="memitem:ad966f78ba21ac22b33b036d94958ff82"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#ad966f78ba21ac22b33b036d94958ff82">satisfiesPositionLimits</a> (const Eigen::Ref&lt; const Eigen::Matrix&lt; FloatType, Eigen::Dynamic, 1 &gt; &gt; &amp;joint_positions, const Eigen::Ref&lt; const Eigen::Matrix&lt; FloatType, Eigen::Dynamic, 2 &gt; &gt; &amp;position_limits, FloatType max_diff=static_cast&lt; FloatType &gt;(1e-6), FloatType max_rel_diff=std::numeric_limits&lt; FloatType &gt;::epsilon())</td></tr>
<tr class="memdesc:ad966f78ba21ac22b33b036d94958ff82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if joint position is within bounds or relatively equal to a limit.  <a href="../../df/da9/namespacetesseract__common.html#ad966f78ba21ac22b33b036d94958ff82">More...</a><br /></td></tr>
<tr class="separator:ad966f78ba21ac22b33b036d94958ff82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b11bad846aa502a484a8586f78c2a09"><td class="memTemplParams" colspan="2">template&lt;typename FloatType &gt; </td></tr>
<tr class="memitem:a1b11bad846aa502a484a8586f78c2a09"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a1b11bad846aa502a484a8586f78c2a09">enforcePositionLimits</a> (Eigen::Ref&lt; Eigen::Matrix&lt; FloatType, Eigen::Dynamic, 1 &gt; &gt; joint_positions, const Eigen::Ref&lt; const Eigen::Matrix&lt; FloatType, Eigen::Dynamic, 2 &gt; &gt; &amp;position_limits)</td></tr>
<tr class="memdesc:a1b11bad846aa502a484a8586f78c2a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enforce position to be within the provided limits.  <a href="../../df/da9/namespacetesseract__common.html#a1b11bad846aa502a484a8586f78c2a09">More...</a><br /></td></tr>
<tr class="separator:a1b11bad846aa502a484a8586f78c2a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c2ec207efac0e2080c6488163eb082"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#af2c2ec207efac0e2080c6488163eb082">parseEnvironmentVariableList</a> (const std::string &amp;env_variable)</td></tr>
<tr class="separator:af2c2ec207efac0e2080c6488163eb082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d07851ebdfbd06448599d1c188a2a50"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a4d07851ebdfbd06448599d1c188a2a50">getAllSearchPaths</a> (const std::string &amp;search_paths_env, const std::set&lt; std::string &gt; &amp;existing_search_paths)</td></tr>
<tr class="separator:a4d07851ebdfbd06448599d1c188a2a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6649a8ac1b3dcd569656074bbcfce030"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a6649a8ac1b3dcd569656074bbcfce030">getAllSearchLibraries</a> (const std::string &amp;search_libraries_env, const std::set&lt; std::string &gt; &amp;existing_search_libraries)</td></tr>
<tr class="separator:a6649a8ac1b3dcd569656074bbcfce030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10d68b681f3d352a15736ffef688010"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#ad10d68b681f3d352a15736ffef688010">extractLibrariesWithFullPath</a> (std::set&lt; std::string &gt; &amp;library_names)</td></tr>
<tr class="memdesc:ad10d68b681f3d352a15736ffef688010"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will remove libraries with full path in the provided library_names and return them.  <a href="../../df/da9/namespacetesseract__common.html#ad10d68b681f3d352a15736ffef688010">More...</a><br /></td></tr>
<tr class="separator:ad10d68b681f3d352a15736ffef688010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11bc9620a27eede3300420410e0b4a7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/da9/namespacetesseract__common.html#a5b28b7ae665b374a7ca166d496f648ce">LinkNamesPair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a11bc9620a27eede3300420410e0b4a7a">makeOrderedLinkPair</a> (const std::string &amp;link_name1, const std::string &amp;link_name2)</td></tr>
<tr class="memdesc:a11bc9620a27eede3300420410e0b4a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pair of strings, where the pair.first is always &lt;= pair.second.  <a href="../../df/da9/namespacetesseract__common.html#a11bc9620a27eede3300420410e0b4a7a">More...</a><br /></td></tr>
<tr class="separator:a11bc9620a27eede3300420410e0b4a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5330a58c8c79cce5559a316e76118558"><td class="memTemplParams" colspan="2">template&lt;typename SerializableType &gt; </td></tr>
<tr class="memitem:a5330a58c8c79cce5559a316e76118558"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a5330a58c8c79cce5559a316e76118558">testSerialization</a> (const SerializableType &amp;<a class="el" href="../../d4/d44/tesseract__common__serialization__unit_8cpp.html#a374f34993cc4a656388815cc9b64fa63">object</a>, const std::string &amp;typename_string)</td></tr>
<tr class="memdesc:a5330a58c8c79cce5559a316e76118558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests Boost serialization for a serializable type.  <a href="../../df/da9/namespacetesseract__common.html#a5330a58c8c79cce5559a316e76118558">More...</a><br /></td></tr>
<tr class="separator:a5330a58c8c79cce5559a316e76118558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b449b344d06caa397190a9a82dd507a"><td class="memTemplParams" colspan="2">template&lt;typename SerializableType &gt; </td></tr>
<tr class="memitem:a1b449b344d06caa397190a9a82dd507a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a1b449b344d06caa397190a9a82dd507a">testSerializationPtr</a> (const std::shared_ptr&lt; SerializableType &gt; &amp;<a class="el" href="../../d4/d44/tesseract__common__serialization__unit_8cpp.html#a374f34993cc4a656388815cc9b64fa63">object</a>, const std::string &amp;typename_string)</td></tr>
<tr class="memdesc:a1b449b344d06caa397190a9a82dd507a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests Boost serialization of shared pointer for a serializable type.  <a href="../../df/da9/namespacetesseract__common.html#a1b449b344d06caa397190a9a82dd507a">More...</a><br /></td></tr>
<tr class="separator:a1b449b344d06caa397190a9a82dd507a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cf5fe962e9933b44d1f8248f0ab2fb"><td class="memTemplParams" colspan="2">template&lt;typename SerializableTypeBase , typename SerializableTypeDerived &gt; </td></tr>
<tr class="memitem:aa8cf5fe962e9933b44d1f8248f0ab2fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#aa8cf5fe962e9933b44d1f8248f0ab2fb">testSerializationDerivedClass</a> (const std::shared_ptr&lt; SerializableTypeBase &gt; &amp;<a class="el" href="../../d4/d44/tesseract__common__serialization__unit_8cpp.html#a374f34993cc4a656388815cc9b64fa63">object</a>, const std::string &amp;typename_string)</td></tr>
<tr class="memdesc:aa8cf5fe962e9933b44d1f8248f0ab2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests Boost serialization for a serializable derived type.  <a href="../../df/da9/namespacetesseract__common.html#aa8cf5fe962e9933b44d1f8248f0ab2fb">More...</a><br /></td></tr>
<tr class="separator:aa8cf5fe962e9933b44d1f8248f0ab2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f13ad2a741226ab5255302f6750ed4a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a7f13ad2a741226ab5255302f6750ed4a"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a7f13ad2a741226ab5255302f6750ed4a">strFormat</a> (const std::string &amp;format, Args... args)</td></tr>
<tr class="separator:a7f13ad2a741226ab5255302f6750ed4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca142577b0d587606411468a2163106f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#aca142577b0d587606411468a2163106f">fileToString</a> (const tesseract_common::fs::path &amp;filepath)</td></tr>
<tr class="memdesc:aca142577b0d587606411468a2163106f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in the contents of the file into a string.  <a href="../../df/da9/namespacetesseract__common.html#aca142577b0d587606411468a2163106f">More...</a><br /></td></tr>
<tr class="separator:aca142577b0d587606411468a2163106f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed12ea384452e2d5d4f7a0854035384"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a4ed12ea384452e2d5d4f7a0854035384">twistChangeRefPoint</a> (Eigen::Ref&lt; Eigen::VectorXd &gt; twist, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;ref_point)</td></tr>
<tr class="memdesc:a4ed12ea384452e2d5d4f7a0854035384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the reference point of the provided Twist.  <a href="../../df/da9/namespacetesseract__common.html#a4ed12ea384452e2d5d4f7a0854035384">More...</a><br /></td></tr>
<tr class="separator:a4ed12ea384452e2d5d4f7a0854035384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c27df906a6e17d088772d3d1c21a5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a98c27df906a6e17d088772d3d1c21a5d">twistChangeBase</a> (Eigen::Ref&lt; Eigen::VectorXd &gt; twist, const Eigen::Isometry3d &amp;change_base)</td></tr>
<tr class="memdesc:a98c27df906a6e17d088772d3d1c21a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the base coordinate system of the Twist.  <a href="../../df/da9/namespacetesseract__common.html#a98c27df906a6e17d088772d3d1c21a5d">More...</a><br /></td></tr>
<tr class="separator:a98c27df906a6e17d088772d3d1c21a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b00920e39050a4b9df5e3100aac7e55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a9b00920e39050a4b9df5e3100aac7e55">jacobianChangeBase</a> (Eigen::Ref&lt; Eigen::MatrixXd &gt; <a class="el" href="../../d4/d0f/kinematics__core__unit_8cpp.html#afd43241933d01af91643a779b829d7a7">jacobian</a>, const Eigen::Isometry3d &amp;change_base)</td></tr>
<tr class="memdesc:a9b00920e39050a4b9df5e3100aac7e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the base coordinate system of the jacobian.  <a href="../../df/da9/namespacetesseract__common.html#a9b00920e39050a4b9df5e3100aac7e55">More...</a><br /></td></tr>
<tr class="separator:a9b00920e39050a4b9df5e3100aac7e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5043afd3f3dbdd6655d543e09a7c9ea4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a5043afd3f3dbdd6655d543e09a7c9ea4">jacobianChangeRefPoint</a> (Eigen::Ref&lt; Eigen::MatrixXd &gt; <a class="el" href="../../d4/d0f/kinematics__core__unit_8cpp.html#afd43241933d01af91643a779b829d7a7">jacobian</a>, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;ref_point)</td></tr>
<tr class="memdesc:a5043afd3f3dbdd6655d543e09a7c9ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the reference point of the jacobian.  <a href="../../df/da9/namespacetesseract__common.html#a5043afd3f3dbdd6655d543e09a7c9ea4">More...</a><br /></td></tr>
<tr class="separator:a5043afd3f3dbdd6655d543e09a7c9ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757f1e4610f79b4e79e796c698a3c113"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a757f1e4610f79b4e79e796c698a3c113">concat</a> (const Eigen::VectorXd &amp;a, const Eigen::VectorXd &amp;b)</td></tr>
<tr class="memdesc:a757f1e4610f79b4e79e796c698a3c113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two vector.  <a href="../../df/da9/namespacetesseract__common.html#a757f1e4610f79b4e79e796c698a3c113">More...</a><br /></td></tr>
<tr class="separator:a757f1e4610f79b4e79e796c698a3c113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715e8a56239e73ccfa00e82cda79a28c"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a715e8a56239e73ccfa00e82cda79a28c">calcRotationalError</a> (const Eigen::Ref&lt; const Eigen::Matrix3d &gt; &amp;R)</td></tr>
<tr class="memdesc:a715e8a56239e73ccfa00e82cda79a28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the rotation error vector given a rotation error matrix where the angle is between [-pi, pi].  <a href="../../df/da9/namespacetesseract__common.html#a715e8a56239e73ccfa00e82cda79a28c">More...</a><br /></td></tr>
<tr class="separator:a715e8a56239e73ccfa00e82cda79a28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a6314e5371fa9604c459b85f159afd"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a41a6314e5371fa9604c459b85f159afd">calcRotationalError2</a> (const Eigen::Ref&lt; const Eigen::Matrix3d &gt; &amp;R)</td></tr>
<tr class="memdesc:a41a6314e5371fa9604c459b85f159afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the rotation error vector given a rotation error matrix where the angle is between [0, 2 * pi].  <a href="../../df/da9/namespacetesseract__common.html#a41a6314e5371fa9604c459b85f159afd">More...</a><br /></td></tr>
<tr class="separator:a41a6314e5371fa9604c459b85f159afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913b8ec499e3bfe779dc95bae54f39d4"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a913b8ec499e3bfe779dc95bae54f39d4">calcTransformError</a> (const Eigen::Isometry3d &amp;t1, const Eigen::Isometry3d &amp;t2)</td></tr>
<tr class="memdesc:a913b8ec499e3bfe779dc95bae54f39d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate error between two transforms expressed in t1 coordinate system.  <a href="../../df/da9/namespacetesseract__common.html#a913b8ec499e3bfe779dc95bae54f39d4">More...</a><br /></td></tr>
<tr class="separator:a913b8ec499e3bfe779dc95bae54f39d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d105162c2cd10693e7387cb74d8318b"><td class="memItemLeft" align="right" valign="top">Eigen::Vector4d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a0d105162c2cd10693e7387cb74d8318b">computeRandomColor</a> ()</td></tr>
<tr class="memdesc:a0d105162c2cd10693e7387cb74d8318b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This computes a random color RGBA [0, 1] with alpha set to 1.  <a href="../../df/da9/namespacetesseract__common.html#a0d105162c2cd10693e7387cb74d8318b">More...</a><br /></td></tr>
<tr class="separator:a0d105162c2cd10693e7387cb74d8318b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e9558332430365cd69cb2eec1784c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#ac4e9558332430365cd69cb2eec1784c8">printNestedException</a> (const std::exception &amp;e, int level=0)</td></tr>
<tr class="memdesc:ac4e9558332430365cd69cb2eec1784c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a nested exception.  <a href="../../df/da9/namespacetesseract__common.html#ac4e9558332430365cd69cb2eec1784c8">More...</a><br /></td></tr>
<tr class="separator:ac4e9558332430365cd69cb2eec1784c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ecad04db85855fa9e4de21084598ca"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a58ecad04db85855fa9e4de21084598ca">getTempPath</a> ()</td></tr>
<tr class="memdesc:a58ecad04db85855fa9e4de21084598ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the host temp directory path.  <a href="../../df/da9/namespacetesseract__common.html#a58ecad04db85855fa9e4de21084598ca">More...</a><br /></td></tr>
<tr class="separator:a58ecad04db85855fa9e4de21084598ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc3a9525efbe582991edd4eedc26079"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a1dc3a9525efbe582991edd4eedc26079">isNumeric</a> (const std::string &amp;<a class="el" href="../../da/dd2/plugin__loader__unit_8cpp.html#aa0d75bebf90ce49ae839876d1d62e199">s</a>)</td></tr>
<tr class="memdesc:a1dc3a9525efbe582991edd4eedc26079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a string is a number.  <a href="../../df/da9/namespacetesseract__common.html#a1dc3a9525efbe582991edd4eedc26079">More...</a><br /></td></tr>
<tr class="separator:a1dc3a9525efbe582991edd4eedc26079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db40f06dba7e6be18a2c4f098ad7a00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a0db40f06dba7e6be18a2c4f098ad7a00">isNumeric</a> (const std::vector&lt; std::string &gt; &amp;sv)</td></tr>
<tr class="memdesc:a0db40f06dba7e6be18a2c4f098ad7a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if each string in vector is a number.  <a href="../../df/da9/namespacetesseract__common.html#a0db40f06dba7e6be18a2c4f098ad7a00">More...</a><br /></td></tr>
<tr class="separator:a0db40f06dba7e6be18a2c4f098ad7a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14552337385ce1de42da699506f8b03"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#aa14552337385ce1de42da699506f8b03">generateRandomNumber</a> (const Eigen::Ref&lt; const Eigen::MatrixX2d &gt; &amp;<a class="el" href="../../dd/dc3/tesseract__scene__graph__joint__unit_8cpp.html#a0be90f4a70bf84d8470599423bd3157b">limits</a>)</td></tr>
<tr class="memdesc:aa14552337385ce1de42da699506f8b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of limits it will generate a vector of random numbers between the limit.  <a href="../../df/da9/namespacetesseract__common.html#aa14552337385ce1de42da699506f8b03">More...</a><br /></td></tr>
<tr class="separator:aa14552337385ce1de42da699506f8b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46edf9701e45b20e95a5abfac500b8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#af46edf9701e45b20e95a5abfac500b8f">ltrim</a> (std::string &amp;<a class="el" href="../../da/dd2/plugin__loader__unit_8cpp.html#aa0d75bebf90ce49ae839876d1d62e199">s</a>)</td></tr>
<tr class="memdesc:af46edf9701e45b20e95a5abfac500b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left trim string.  <a href="../../df/da9/namespacetesseract__common.html#af46edf9701e45b20e95a5abfac500b8f">More...</a><br /></td></tr>
<tr class="separator:af46edf9701e45b20e95a5abfac500b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86a4f0e5ca9d2b1f5abc3f34735d85b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#aa86a4f0e5ca9d2b1f5abc3f34735d85b">rtrim</a> (std::string &amp;<a class="el" href="../../da/dd2/plugin__loader__unit_8cpp.html#aa0d75bebf90ce49ae839876d1d62e199">s</a>)</td></tr>
<tr class="memdesc:aa86a4f0e5ca9d2b1f5abc3f34735d85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right trim string.  <a href="../../df/da9/namespacetesseract__common.html#aa86a4f0e5ca9d2b1f5abc3f34735d85b">More...</a><br /></td></tr>
<tr class="separator:aa86a4f0e5ca9d2b1f5abc3f34735d85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacd629bcf585286917aafa7b8e603bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#aeacd629bcf585286917aafa7b8e603bb">trim</a> (std::string &amp;<a class="el" href="../../da/dd2/plugin__loader__unit_8cpp.html#aa0d75bebf90ce49ae839876d1d62e199">s</a>)</td></tr>
<tr class="memdesc:aeacd629bcf585286917aafa7b8e603bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim left and right of string.  <a href="../../df/da9/namespacetesseract__common.html#aeacd629bcf585286917aafa7b8e603bb">More...</a><br /></td></tr>
<tr class="separator:aeacd629bcf585286917aafa7b8e603bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d98b9f0df320e12b9f9686761f5b1e"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &gt; </td></tr>
<tr class="memitem:a34d98b9f0df320e12b9f9686761f5b1e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a34d98b9f0df320e12b9f9686761f5b1e">isIdentical</a> (const std::vector&lt; <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &gt; &amp;vec1, const std::vector&lt; <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &gt; &amp;vec2, bool ordered=true, const std::function&lt; bool(const <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &amp;, const <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &amp;)&gt; &amp;equal_pred=[](const <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &amp;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a78e1cc09f129a731d55ed82bc47956a7">v1</a>, const <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &amp;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a23dd5e7fffd5f8400cbed32a5071f236">v2</a>) { return <a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a78e1cc09f129a731d55ed82bc47956a7">v1</a>==<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a23dd5e7fffd5f8400cbed32a5071f236">v2</a>;}, const std::function&lt; bool(const <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &amp;, const <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &amp;)&gt; &amp;comp=[](const <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &amp;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a78e1cc09f129a731d55ed82bc47956a7">v1</a>, const <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &amp;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a23dd5e7fffd5f8400cbed32a5071f236">v2</a>) { return <a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a78e1cc09f129a731d55ed82bc47956a7">v1</a>&lt; <a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a23dd5e7fffd5f8400cbed32a5071f236">v2</a>;})</td></tr>
<tr class="memdesc:a34d98b9f0df320e12b9f9686761f5b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two vector of strings are identical.  <a href="../../df/da9/namespacetesseract__common.html#a34d98b9f0df320e12b9f9686761f5b1e">More...</a><br /></td></tr>
<tr class="separator:a34d98b9f0df320e12b9f9686761f5b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be902621fe3d33f5fe7d72116196f24"><td class="memTemplParams" colspan="2">template&lt;typename KeyValueContainerType , typename ValueType &gt; </td></tr>
<tr class="memitem:a4be902621fe3d33f5fe7d72116196f24"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a4be902621fe3d33f5fe7d72116196f24">isIdenticalMap</a> (const KeyValueContainerType &amp;map_1, const KeyValueContainerType &amp;map_2, const std::function&lt; bool(const ValueType &amp;, const ValueType &amp;)&gt; &amp;value_eq=[](const ValueType &amp;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a78e1cc09f129a731d55ed82bc47956a7">v1</a>, const ValueType &amp;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a23dd5e7fffd5f8400cbed32a5071f236">v2</a>) { return <a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a78e1cc09f129a731d55ed82bc47956a7">v1</a>==<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a23dd5e7fffd5f8400cbed32a5071f236">v2</a>;})</td></tr>
<tr class="memdesc:a4be902621fe3d33f5fe7d72116196f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if 2 maps are identical.  <a href="../../df/da9/namespacetesseract__common.html#a4be902621fe3d33f5fe7d72116196f24">More...</a><br /></td></tr>
<tr class="separator:a4be902621fe3d33f5fe7d72116196f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129feb5b5288a992d9fb72ba5dbb579d"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a129feb5b5288a992d9fb72ba5dbb579d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a129feb5b5288a992d9fb72ba5dbb579d">isIdenticalSet</a> (const std::set&lt; ValueType &gt; &amp;set_1, const std::set&lt; ValueType &gt; &amp;set_2, const std::function&lt; bool(const ValueType &amp;, const ValueType &amp;)&gt; &amp;value_eq=[](const ValueType &amp;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a78e1cc09f129a731d55ed82bc47956a7">v1</a>, const ValueType &amp;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a23dd5e7fffd5f8400cbed32a5071f236">v2</a>) { return <a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a78e1cc09f129a731d55ed82bc47956a7">v1</a>==<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a23dd5e7fffd5f8400cbed32a5071f236">v2</a>;})</td></tr>
<tr class="memdesc:a129feb5b5288a992d9fb72ba5dbb579d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if 2 sets are identical.  <a href="../../df/da9/namespacetesseract__common.html#a129feb5b5288a992d9fb72ba5dbb579d">More...</a><br /></td></tr>
<tr class="separator:a129feb5b5288a992d9fb72ba5dbb579d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7498ab87445e5c870e74a7d3cbc78f"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , std::size_t Size&gt; </td></tr>
<tr class="memitem:aff7498ab87445e5c870e74a7d3cbc78f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#aff7498ab87445e5c870e74a7d3cbc78f">isIdenticalArray</a> (const std::array&lt; ValueType, Size &gt; &amp;array_1, const std::array&lt; ValueType, Size &gt; &amp;array_2, const std::function&lt; bool(const ValueType &amp;, const ValueType &amp;)&gt; &amp;value_eq=[](const ValueType &amp;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a78e1cc09f129a731d55ed82bc47956a7">v1</a>, const ValueType &amp;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a23dd5e7fffd5f8400cbed32a5071f236">v2</a>) { return <a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a78e1cc09f129a731d55ed82bc47956a7">v1</a>==<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a23dd5e7fffd5f8400cbed32a5071f236">v2</a>;})</td></tr>
<tr class="memdesc:aff7498ab87445e5c870e74a7d3cbc78f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if 2 arrays are identical.  <a href="../../df/da9/namespacetesseract__common.html#aff7498ab87445e5c870e74a7d3cbc78f">More...</a><br /></td></tr>
<tr class="separator:aff7498ab87445e5c870e74a7d3cbc78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65966457329351239c51b09ec1a8d3a4"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &gt; </td></tr>
<tr class="memitem:a65966457329351239c51b09ec1a8d3a4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a65966457329351239c51b09ec1a8d3a4">pointersEqual</a> (const std::shared_ptr&lt; <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &gt; &amp;p1, const std::shared_ptr&lt; <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &gt; &amp;p2)</td></tr>
<tr class="memdesc:a65966457329351239c51b09ec1a8d3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if 2 pointers point to objects that are ==.  <a href="../../df/da9/namespacetesseract__common.html#a65966457329351239c51b09ec1a8d3a4">More...</a><br /></td></tr>
<tr class="separator:a65966457329351239c51b09ec1a8d3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5691a34b0a37453566326959831fb6df"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &gt; </td></tr>
<tr class="memitem:a5691a34b0a37453566326959831fb6df"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a5691a34b0a37453566326959831fb6df">pointersComparison</a> (const std::shared_ptr&lt; <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &gt; &amp;p1, const std::shared_ptr&lt; <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &gt; &amp;p2)</td></tr>
<tr class="memdesc:a5691a34b0a37453566326959831fb6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator for the objects 2 points point to.  <a href="../../df/da9/namespacetesseract__common.html#a5691a34b0a37453566326959831fb6df">More...</a><br /></td></tr>
<tr class="separator:a5691a34b0a37453566326959831fb6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1077809c98ad8bf5262e426cff6e63a3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a1077809c98ad8bf5262e426cff6e63a3">getTimestampString</a> ()</td></tr>
<tr class="memdesc:a1077809c98ad8bf5262e426cff6e63a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Timestamp string.  <a href="../../df/da9/namespacetesseract__common.html#a1077809c98ad8bf5262e426cff6e63a3">More...</a><br /></td></tr>
<tr class="separator:a1077809c98ad8bf5262e426cff6e63a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da14d8e3b6c20175711209343aafe2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a7da14d8e3b6c20175711209343aafe2f">reorder</a> (Eigen::Ref&lt; Eigen::VectorXd &gt; <a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#ac4055e3a20b6b3af3d10590ea446ef6c">v</a>, std::vector&lt; Eigen::Index &gt; order)</td></tr>
<tr class="memdesc:a7da14d8e3b6c20175711209343aafe2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder Eigen::VectorXd implace given index list.  <a href="../../df/da9/namespacetesseract__common.html#a7da14d8e3b6c20175711209343aafe2f">More...</a><br /></td></tr>
<tr class="separator:a7da14d8e3b6c20175711209343aafe2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a3ebd3610dce6d24cc7569606fd9ab"><td class="memItemLeft" align="right" valign="top">tinyxml2::XMLError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#ae1a3ebd3610dce6d24cc7569606fd9ab">QueryStringValue</a> (const tinyxml2::XMLElement *xml_element, std::string &amp;<a class="el" href="../../d4/d44/tesseract__common__serialization__unit_8cpp.html#a767de28b215ddaceb31188034a0838c0">value</a>)</td></tr>
<tr class="memdesc:ae1a3ebd3610dce6d24cc7569606fd9ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a string value from xml element.  <a href="../../df/da9/namespacetesseract__common.html#ae1a3ebd3610dce6d24cc7569606fd9ab">More...</a><br /></td></tr>
<tr class="separator:ae1a3ebd3610dce6d24cc7569606fd9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95676b5418063a1d7c84fbba4ff1fe0"><td class="memItemLeft" align="right" valign="top">tinyxml2::XMLError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#ab95676b5418063a1d7c84fbba4ff1fe0">QueryStringText</a> (const tinyxml2::XMLElement *xml_element, std::string &amp;text)</td></tr>
<tr class="memdesc:ab95676b5418063a1d7c84fbba4ff1fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a string Text from xml element.  <a href="../../df/da9/namespacetesseract__common.html#ab95676b5418063a1d7c84fbba4ff1fe0">More...</a><br /></td></tr>
<tr class="separator:ab95676b5418063a1d7c84fbba4ff1fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e6914a612484e89bf86c60198b6cdc"><td class="memItemLeft" align="right" valign="top">tinyxml2::XMLError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#ad3e6914a612484e89bf86c60198b6cdc">QueryStringValue</a> (const tinyxml2::XMLAttribute *xml_attribute, std::string &amp;<a class="el" href="../../d4/d44/tesseract__common__serialization__unit_8cpp.html#a767de28b215ddaceb31188034a0838c0">value</a>)</td></tr>
<tr class="memdesc:ad3e6914a612484e89bf86c60198b6cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a string value from xml attribute.  <a href="../../df/da9/namespacetesseract__common.html#ad3e6914a612484e89bf86c60198b6cdc">More...</a><br /></td></tr>
<tr class="separator:ad3e6914a612484e89bf86c60198b6cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a4a1b896230ca84cce7aae2e21673a"><td class="memItemLeft" align="right" valign="top">tinyxml2::XMLError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a22a4a1b896230ca84cce7aae2e21673a">QueryStringAttribute</a> (const tinyxml2::XMLElement *xml_element, const char *<a class="el" href="../../d3/de4/tesseract__scene__graph__link__unit_8cpp.html#a6192562aa9f016b228bd2775afc64ee7">name</a>, std::string &amp;<a class="el" href="../../d4/d44/tesseract__common__serialization__unit_8cpp.html#a767de28b215ddaceb31188034a0838c0">value</a>)</td></tr>
<tr class="memdesc:a22a4a1b896230ca84cce7aae2e21673a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a string attribute from an xml element.  <a href="../../df/da9/namespacetesseract__common.html#a22a4a1b896230ca84cce7aae2e21673a">More...</a><br /></td></tr>
<tr class="separator:a22a4a1b896230ca84cce7aae2e21673a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfa4845aecc119ae62b37e59c6ee168"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#aadfa4845aecc119ae62b37e59c6ee168">StringAttribute</a> (const tinyxml2::XMLElement *xml_element, const char *<a class="el" href="../../d3/de4/tesseract__scene__graph__link__unit_8cpp.html#a6192562aa9f016b228bd2775afc64ee7">name</a>, std::string default_value)</td></tr>
<tr class="memdesc:aadfa4845aecc119ae62b37e59c6ee168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get string attribute if exist. If it does not exist it returns the default value.  <a href="../../df/da9/namespacetesseract__common.html#aadfa4845aecc119ae62b37e59c6ee168">More...</a><br /></td></tr>
<tr class="separator:aadfa4845aecc119ae62b37e59c6ee168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609734264f8b63f5c7815871c40b231f"><td class="memItemLeft" align="right" valign="top">tinyxml2::XMLError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a609734264f8b63f5c7815871c40b231f">QueryStringAttributeRequired</a> (const tinyxml2::XMLElement *xml_element, const char *<a class="el" href="../../d3/de4/tesseract__scene__graph__link__unit_8cpp.html#a6192562aa9f016b228bd2775afc64ee7">name</a>, std::string &amp;<a class="el" href="../../d4/d44/tesseract__common__serialization__unit_8cpp.html#a767de28b215ddaceb31188034a0838c0">value</a>)</td></tr>
<tr class="memdesc:a609734264f8b63f5c7815871c40b231f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a string attribute from an xml element and print error log.  <a href="../../df/da9/namespacetesseract__common.html#a609734264f8b63f5c7815871c40b231f">More...</a><br /></td></tr>
<tr class="separator:a609734264f8b63f5c7815871c40b231f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ec94b62bea51b6e40598e0f8e7a6c3"><td class="memItemLeft" align="right" valign="top">tinyxml2::XMLError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#ab5ec94b62bea51b6e40598e0f8e7a6c3">QueryDoubleAttributeRequired</a> (const tinyxml2::XMLElement *xml_element, const char *<a class="el" href="../../d3/de4/tesseract__scene__graph__link__unit_8cpp.html#a6192562aa9f016b228bd2775afc64ee7">name</a>, double &amp;<a class="el" href="../../d4/d44/tesseract__common__serialization__unit_8cpp.html#a767de28b215ddaceb31188034a0838c0">value</a>)</td></tr>
<tr class="memdesc:ab5ec94b62bea51b6e40598e0f8e7a6c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a double attribute from an xml element and print error log.  <a href="../../df/da9/namespacetesseract__common.html#ab5ec94b62bea51b6e40598e0f8e7a6c3">More...</a><br /></td></tr>
<tr class="separator:ab5ec94b62bea51b6e40598e0f8e7a6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a12946985d34fc3b1fcfb61b473f8b"><td class="memItemLeft" align="right" valign="top">tinyxml2::XMLError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#ad9a12946985d34fc3b1fcfb61b473f8b">QueryIntAttributeRequired</a> (const tinyxml2::XMLElement *xml_element, const char *<a class="el" href="../../d3/de4/tesseract__scene__graph__link__unit_8cpp.html#a6192562aa9f016b228bd2775afc64ee7">name</a>, int &amp;<a class="el" href="../../d4/d44/tesseract__common__serialization__unit_8cpp.html#a767de28b215ddaceb31188034a0838c0">value</a>)</td></tr>
<tr class="memdesc:ad9a12946985d34fc3b1fcfb61b473f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a int attribute from an xml element and print error log.  <a href="../../df/da9/namespacetesseract__common.html#ad9a12946985d34fc3b1fcfb61b473f8b">More...</a><br /></td></tr>
<tr class="separator:ad9a12946985d34fc3b1fcfb61b473f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9961ff2a5d322165a817241b7746f64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#ac9961ff2a5d322165a817241b7746f64">almostEqualRelativeAndAbs</a> (double a, double b, double max_diff=1e-6, double max_rel_diff=std::numeric_limits&lt; double &gt;::epsilon())</td></tr>
<tr class="memdesc:ac9961ff2a5d322165a817241b7746f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two double are relatively equal.  <a href="../../df/da9/namespacetesseract__common.html#ac9961ff2a5d322165a817241b7746f64">More...</a><br /></td></tr>
<tr class="separator:ac9961ff2a5d322165a817241b7746f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12eb899ec3967699e946431730eed959"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a12eb899ec3967699e946431730eed959">almostEqualRelativeAndAbs</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a78e1cc09f129a731d55ed82bc47956a7">v1</a>, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a23dd5e7fffd5f8400cbed32a5071f236">v2</a>, double max_diff=1e-6, double max_rel_diff=std::numeric_limits&lt; double &gt;::epsilon())</td></tr>
<tr class="memdesc:a12eb899ec3967699e946431730eed959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two Eigen VectorXd are relatively and absolute equal.  <a href="../../df/da9/namespacetesseract__common.html#a12eb899ec3967699e946431730eed959">More...</a><br /></td></tr>
<tr class="separator:a12eb899ec3967699e946431730eed959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb8b43bdac2751a9a899e4552537cda"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a8eb8b43bdac2751a9a899e4552537cda">almostEqualRelativeAndAbs</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a78e1cc09f129a731d55ed82bc47956a7">v1</a>, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a23dd5e7fffd5f8400cbed32a5071f236">v2</a>, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;max_diff, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;max_rel_diff)</td></tr>
<tr class="memdesc:a8eb8b43bdac2751a9a899e4552537cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two Eigen VectorXd are relatively and absolute equal.  <a href="../../df/da9/namespacetesseract__common.html#a8eb8b43bdac2751a9a899e4552537cda">More...</a><br /></td></tr>
<tr class="separator:a8eb8b43bdac2751a9a899e4552537cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00bc131acfeba0eba8fe7ff7cd944860"><td class="memTemplParams" colspan="2">template&lt;typename FloatType &gt; </td></tr>
<tr class="memitem:a00bc131acfeba0eba8fe7ff7cd944860"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a00bc131acfeba0eba8fe7ff7cd944860">toNumeric</a> (const std::string &amp;<a class="el" href="../../da/dd2/plugin__loader__unit_8cpp.html#aa0d75bebf90ce49ae839876d1d62e199">s</a>, FloatType &amp;<a class="el" href="../../d4/d44/tesseract__common__serialization__unit_8cpp.html#a767de28b215ddaceb31188034a0838c0">value</a>)</td></tr>
<tr class="memdesc:a00bc131acfeba0eba8fe7ff7cd944860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a numeric value type.  <a href="../../df/da9/namespacetesseract__common.html#a00bc131acfeba0eba8fe7ff7cd944860">More...</a><br /></td></tr>
<tr class="separator:a00bc131acfeba0eba8fe7ff7cd944860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca6ae7b6cbd8d28ad6e141239a0206f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#aaca6ae7b6cbd8d28ad6e141239a0206f">getAllowedCollisions</a> (const std::vector&lt; std::string &gt; &amp;<a class="el" href="../../d4/d09/collision__core__unit_8cpp.html#a464caf777ea79db067179ebe2bd7ecc7">link_names</a>, const <a class="el" href="../../df/da9/namespacetesseract__common.html#a79d2a34647d0da5e574629878c142086">AllowedCollisionEntries</a> &amp;acm_entries, bool remove_duplicates=true)</td></tr>
<tr class="memdesc:aaca6ae7b6cbd8d28ad6e141239a0206f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets allowed collisions for a set of link names.  <a href="../../df/da9/namespacetesseract__common.html#aaca6ae7b6cbd8d28ad6e141239a0206f">More...</a><br /></td></tr>
<tr class="separator:aaca6ae7b6cbd8d28ad6e141239a0206f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b13b4e33c343e723310e3b0e1c59e9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a83b13b4e33c343e723310e3b0e1c59e9">toYAMLString</a> (const YAML::Node &amp;node)</td></tr>
<tr class="memdesc:a83b13b4e33c343e723310e3b0e1c59e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a YAML::Node to a yaml string.  <a href="../../df/da9/namespacetesseract__common.html#a83b13b4e33c343e723310e3b0e1c59e9">More...</a><br /></td></tr>
<tr class="separator:a83b13b4e33c343e723310e3b0e1c59e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f354484775381dd5c207ee0dfe21f2"><td class="memItemLeft" align="right" valign="top">YAML::Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#ac8f354484775381dd5c207ee0dfe21f2">fromYAMLString</a> (const std::string &amp;string)</td></tr>
<tr class="memdesc:ac8f354484775381dd5c207ee0dfe21f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts yaml string to a YAML::Node.  <a href="../../df/da9/namespacetesseract__common.html#ac8f354484775381dd5c207ee0dfe21f2">More...</a><br /></td></tr>
<tr class="separator:ac8f354484775381dd5c207ee0dfe21f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631a653d4a106106694065f7b88ede26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a631a653d4a106106694065f7b88ede26">compareYAML</a> (const YAML::Node &amp;node1, const YAML::Node &amp;node2)</td></tr>
<tr class="memdesc:a631a653d4a106106694065f7b88ede26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the YAML::Nodes are identical.  <a href="../../df/da9/namespacetesseract__common.html#a631a653d4a106106694065f7b88ede26">More...</a><br /></td></tr>
<tr class="separator:a631a653d4a106106694065f7b88ede26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ebb17906855938c53c073603e40143"><td class="memItemLeft" align="right" valign="top">template bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a14ebb17906855938c53c073603e40143">isWithinPositionLimits&lt; float &gt;</a> (const Eigen::Ref&lt; const Eigen::Matrix&lt; float, Eigen::Dynamic, 1 &gt; &gt; &amp;joint_positions, const Eigen::Ref&lt; const Eigen::Matrix&lt; float, Eigen::Dynamic, 2 &gt; &gt; &amp;position_limits)</td></tr>
<tr class="separator:a14ebb17906855938c53c073603e40143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39ab29a90ad257cf5418b8eeb77e4af"><td class="memItemLeft" align="right" valign="top">template bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#ad39ab29a90ad257cf5418b8eeb77e4af">isWithinPositionLimits&lt; double &gt;</a> (const Eigen::Ref&lt; const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &gt; &amp;joint_positions, const Eigen::Ref&lt; const Eigen::Matrix&lt; double, Eigen::Dynamic, 2 &gt; &gt; &amp;position_limits)</td></tr>
<tr class="separator:ad39ab29a90ad257cf5418b8eeb77e4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b4f11e829b5fba3c3d80d5a1f4b6e2"><td class="memItemLeft" align="right" valign="top">template bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a70b4f11e829b5fba3c3d80d5a1f4b6e2">satisfiesPositionLimits&lt; float &gt;</a> (const Eigen::Ref&lt; const Eigen::Matrix&lt; float, Eigen::Dynamic, 1 &gt; &gt; &amp;joint_positions, const Eigen::Ref&lt; const Eigen::Matrix&lt; float, Eigen::Dynamic, 2 &gt; &gt; &amp;position_limits, float max_diff, float max_rel_diff)</td></tr>
<tr class="separator:a70b4f11e829b5fba3c3d80d5a1f4b6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2357c2476cbb1427a259d1dc1b8c20b6"><td class="memItemLeft" align="right" valign="top">template bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a2357c2476cbb1427a259d1dc1b8c20b6">satisfiesPositionLimits&lt; double &gt;</a> (const Eigen::Ref&lt; const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &gt; &amp;joint_positions, const Eigen::Ref&lt; const Eigen::Matrix&lt; double, Eigen::Dynamic, 2 &gt; &gt; &amp;position_limits, double max_diff, double max_rel_diff)</td></tr>
<tr class="separator:a2357c2476cbb1427a259d1dc1b8c20b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abacf44e7b4b89c7b47c11eaae1296428"><td class="memItemLeft" align="right" valign="top">template bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#abacf44e7b4b89c7b47c11eaae1296428">satisfiesPositionLimits&lt; float &gt;</a> (const Eigen::Ref&lt; const Eigen::Matrix&lt; float, Eigen::Dynamic, 1 &gt; &gt; &amp;joint_positions, const Eigen::Ref&lt; const Eigen::Matrix&lt; float, Eigen::Dynamic, 2 &gt; &gt; &amp;position_limits, const Eigen::Ref&lt; const Eigen::Matrix&lt; float, Eigen::Dynamic, 1 &gt; &gt; &amp;max_diff, const Eigen::Ref&lt; const Eigen::Matrix&lt; float, Eigen::Dynamic, 1 &gt; &gt; &amp;max_rel_diff)</td></tr>
<tr class="separator:abacf44e7b4b89c7b47c11eaae1296428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecbdd93583ff717604b4fc32b1015b39"><td class="memItemLeft" align="right" valign="top">template bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#aecbdd93583ff717604b4fc32b1015b39">satisfiesPositionLimits&lt; double &gt;</a> (const Eigen::Ref&lt; const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &gt; &amp;joint_positions, const Eigen::Ref&lt; const Eigen::Matrix&lt; double, Eigen::Dynamic, 2 &gt; &gt; &amp;position_limits, const Eigen::Ref&lt; const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &gt; &amp;max_diff, const Eigen::Ref&lt; const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &gt; &amp;max_rel_diff)</td></tr>
<tr class="separator:aecbdd93583ff717604b4fc32b1015b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df6f30957cf5c867be9ca71aa24e1ab"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a2df6f30957cf5c867be9ca71aa24e1ab">enforcePositionLimits&lt; float &gt;</a> (Eigen::Ref&lt; Eigen::Matrix&lt; float, Eigen::Dynamic, 1 &gt; &gt; joint_positions, const Eigen::Ref&lt; const Eigen::Matrix&lt; float, Eigen::Dynamic, 2 &gt; &gt; &amp;position_limits)</td></tr>
<tr class="separator:a2df6f30957cf5c867be9ca71aa24e1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8d20fecfeb1e99cc55d316977c3f3d"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a1f8d20fecfeb1e99cc55d316977c3f3d">enforcePositionLimits&lt; double &gt;</a> (Eigen::Ref&lt; Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &gt; joint_positions, const Eigen::Ref&lt; const Eigen::Matrix&lt; double, Eigen::Dynamic, 2 &gt; &gt; &amp;position_limits)</td></tr>
<tr class="separator:a1f8d20fecfeb1e99cc55d316977c3f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ca1a2af32cf2aa20666fabebb01ae3"><td class="memItemLeft" align="right" valign="top">template bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#af5ca1a2af32cf2aa20666fabebb01ae3">toNumeric&lt; double &gt;</a> (const std::string &amp;, double &amp;)</td></tr>
<tr class="separator:af5ca1a2af32cf2aa20666fabebb01ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70232725f5f768795d33beb4d783754"><td class="memItemLeft" align="right" valign="top">template bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#aa70232725f5f768795d33beb4d783754">toNumeric&lt; float &gt;</a> (const std::string &amp;, float &amp;)</td></tr>
<tr class="separator:aa70232725f5f768795d33beb4d783754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9e402f37e71867b838508147b93ba7"><td class="memItemLeft" align="right" valign="top">template bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a0b9e402f37e71867b838508147b93ba7">toNumeric&lt; int &gt;</a> (const std::string &amp;, int &amp;)</td></tr>
<tr class="separator:a0b9e402f37e71867b838508147b93ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b11049d2f1fe507189aedf890101ce7"><td class="memItemLeft" align="right" valign="top">template bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a4b11049d2f1fe507189aedf890101ce7">toNumeric&lt; long &gt;</a> (const std::string &amp;, long &amp;)</td></tr>
<tr class="separator:a4b11049d2f1fe507189aedf890101ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e6b461e723426fcfde3465ceb4b79d"><td class="memItemLeft" align="right" valign="top">template bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a81e6b461e723426fcfde3465ceb4b79d">isIdentical&lt; std::string &gt;</a> (const std::vector&lt; std::string &gt; &amp;, const std::vector&lt; std::string &gt; &amp;, bool, const std::function&lt; bool(const std::string &amp;, const std::string &amp;)&gt; &amp;, const std::function&lt; bool(const std::string &amp;, const std::string &amp;)&gt; &amp;)</td></tr>
<tr class="separator:a81e6b461e723426fcfde3465ceb4b79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e39b554da010e8c36060d6d3683518"><td class="memItemLeft" align="right" valign="top">template bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a14e39b554da010e8c36060d6d3683518">isIdentical&lt; Eigen::Index &gt;</a> (const std::vector&lt; Eigen::Index &gt; &amp;, const std::vector&lt; Eigen::Index &gt; &amp;, bool, const std::function&lt; bool(const Eigen::Index &amp;, const Eigen::Index &amp;)&gt; &amp;, const std::function&lt; bool(const Eigen::Index &amp;, const Eigen::Index &amp;)&gt; &amp;)</td></tr>
<tr class="separator:a14e39b554da010e8c36060d6d3683518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713dad4aa33bbdae5fb5aec8e83466e2"><td class="memTemplParams" colspan="2">template&lt;typename E &gt; </td></tr>
<tr class="memitem:a713dad4aa33bbdae5fb5aec8e83466e2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_polymorphic&lt; E &gt;<a class="el" href="../../d4/d44/tesseract__common__serialization__unit_8cpp.html#a767de28b215ddaceb31188034a0838c0">::value</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#a713dad4aa33bbdae5fb5aec8e83466e2">my_rethrow_if_nested</a> (const E &amp;)</td></tr>
<tr class="separator:a713dad4aa33bbdae5fb5aec8e83466e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1990ddb29716885e94980b49c187d8"><td class="memTemplParams" colspan="2">template&lt;typename E &gt; </td></tr>
<tr class="memitem:abc1990ddb29716885e94980b49c187d8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_polymorphic&lt; E &gt;<a class="el" href="../../d4/d44/tesseract__common__serialization__unit_8cpp.html#a767de28b215ddaceb31188034a0838c0">::value</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#abc1990ddb29716885e94980b49c187d8">my_rethrow_if_nested</a> (const E &amp;e)</td></tr>
<tr class="separator:abc1990ddb29716885e94980b49c187d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aef65970d6ccc97d88621f27e7c35b32a"><td class="memItemLeft" align="right" valign="top">static std::mt19937&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da9/namespacetesseract__common.html#aef65970d6ccc97d88621f27e7c35b32a">mersenne</a> { static_cast&lt;std::mt19937::result_type&gt;(std::time(nullptr)) }</td></tr>
<tr class="memdesc:aef65970d6ccc97d88621f27e7c35b32a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random number generator.  <a href="../../df/da9/namespacetesseract__common.html#aef65970d6ccc97d88621f27e7c35b32a">More...</a><br /></td></tr>
<tr class="separator:aef65970d6ccc97d88621f27e7c35b32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a2c5a4b6149060671cf8c3f9d15ef58c4" name="a2c5a4b6149060671cf8c3f9d15ef58c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5a4b6149060671cf8c3f9d15ef58c4">&#9670;&#160;</a></span>AlignedMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../df/da9/namespacetesseract__common.html#a2c5a4b6149060671cf8c3f9d15ef58c4">tesseract_common::AlignedMap</a> = typedef std::map&lt;Key, Value, std::less&lt;Key&gt;, Eigen::aligned_allocator&lt;std::pair&lt;const Key, Value&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a85a5c73ede3e67335c3e09f9f3bc33a3" name="a85a5c73ede3e67335c3e09f9f3bc33a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a5c73ede3e67335c3e09f9f3bc33a3">&#9670;&#160;</a></span>AlignedUnorderedMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../df/da9/namespacetesseract__common.html#a85a5c73ede3e67335c3e09f9f3bc33a3">tesseract_common::AlignedUnorderedMap</a> = typedef std::unordered_map&lt;Key, Value, std::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Eigen::aligned_allocator&lt;std::pair&lt;const Key, Value&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a000d15c3ab8d8ba4ebdaae64153b053a" name="a000d15c3ab8d8ba4ebdaae64153b053a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000d15c3ab8d8ba4ebdaae64153b053a">&#9670;&#160;</a></span>AlignedVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../df/da9/namespacetesseract__common.html#a000d15c3ab8d8ba4ebdaae64153b053a">tesseract_common::AlignedVector</a> = typedef std::vector&lt;<a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a>, Eigen::aligned_allocator&lt;<a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable easy switching to std::filesystem when available. </p>

</div>
</div>
<a id="a79d2a34647d0da5e574629878c142086" name="a79d2a34647d0da5e574629878c142086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d2a34647d0da5e574629878c142086">&#9670;&#160;</a></span>AllowedCollisionEntries</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../df/da9/namespacetesseract__common.html#a79d2a34647d0da5e574629878c142086">tesseract_common::AllowedCollisionEntries</a> = typedef std::unordered_map&lt;<a class="el" href="../../df/da9/namespacetesseract__common.html#a5b28b7ae665b374a7ca166d496f648ce">tesseract_common::LinkNamesPair</a>, std::string, <a class="el" href="../../d7/de0/structtesseract__common_1_1PairHash.html">tesseract_common::PairHash</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b0272abd157d81a79f04aad1a6ddd01" name="a5b0272abd157d81a79f04aad1a6ddd01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0272abd157d81a79f04aad1a6ddd01">&#9670;&#160;</a></span>AnyPolyBase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../df/da9/namespacetesseract__common.html#a5b0272abd157d81a79f04aad1a6ddd01">tesseract_common::AnyPolyBase</a> = typedef <a class="el" href="../../de/d36/structtesseract__common_1_1TypeErasureBase.html">tesseract_common::TypeErasureBase</a>&lt;<a class="el" href="../../d6/dd5/structtesseract__common_1_1TypeErasureInterface.html">TypeErasureInterface</a>, <a class="el" href="../../d1/dd5/structtesseract__common_1_1detail__any_1_1AnyInstance.html">detail_any::AnyInstance</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b28b7ae665b374a7ca166d496f648ce" name="a5b28b7ae665b374a7ca166d496f648ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b28b7ae665b374a7ca166d496f648ce">&#9670;&#160;</a></span>LinkNamesPair</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../df/da9/namespacetesseract__common.html#a5b28b7ae665b374a7ca166d496f648ce">tesseract_common::LinkNamesPair</a> = typedef std::pair&lt;std::string, std::string&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84cc21cc4b384291adbbddaa81fe6447" name="a84cc21cc4b384291adbbddaa81fe6447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84cc21cc4b384291adbbddaa81fe6447">&#9670;&#160;</a></span>PairsCollisionMarginData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../df/da9/namespacetesseract__common.html#a84cc21cc4b384291adbbddaa81fe6447">tesseract_common::PairsCollisionMarginData</a> = typedef std::unordered_map&lt;<a class="el" href="../../df/da9/namespacetesseract__common.html#a5b28b7ae665b374a7ca166d496f648ce">tesseract_common::LinkNamesPair</a>, double, <a class="el" href="../../d7/de0/structtesseract__common_1_1PairHash.html">tesseract_common::PairHash</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a43d1f6e0418164a6db0e1c447150340e" name="a43d1f6e0418164a6db0e1c447150340e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d1f6e0418164a6db0e1c447150340e">&#9670;&#160;</a></span>PluginInfoMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../df/da9/namespacetesseract__common.html#a43d1f6e0418164a6db0e1c447150340e">tesseract_common::PluginInfoMap</a> = typedef std::map&lt;std::string, <a class="el" href="../../d8/d88/structtesseract__common_1_1PluginInfo.html">PluginInfo</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A map of <a class="el" href="../../d8/d88/structtesseract__common_1_1PluginInfo.html" title="The Plugin Information struct.">PluginInfo</a> to user defined name. </p>

</div>
</div>
<a id="a2ef4ec89c4c07fc0a75c4bc24da9681c" name="a2ef4ec89c4c07fc0a75c4bc24da9681c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ef4ec89c4c07fc0a75c4bc24da9681c">&#9670;&#160;</a></span>SimpleResourceLocatorFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../df/da9/namespacetesseract__common.html#a2ef4ec89c4c07fc0a75c4bc24da9681c">tesseract_common::SimpleResourceLocatorFn</a> = typedef std::function&lt;std::string(const std::string&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a917718f518f98714fce17e831ec1ea11" name="a917718f518f98714fce17e831ec1ea11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917718f518f98714fce17e831ec1ea11">&#9670;&#160;</a></span>Toolpath</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../df/da9/namespacetesseract__common.html#a917718f518f98714fce17e831ec1ea11">tesseract_common::Toolpath</a> = typedef <a class="el" href="../../df/da9/namespacetesseract__common.html#a000d15c3ab8d8ba4ebdaae64153b053a">AlignedVector</a>&lt;<a class="el" href="../../df/da9/namespacetesseract__common.html#a94d9921fc7ed323609ac57d06f939cb6">VectorIsometry3d</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a431ff65777ee0bed71e7671390638244" name="a431ff65777ee0bed71e7671390638244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431ff65777ee0bed71e7671390638244">&#9670;&#160;</a></span>TrajArray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../df/da9/namespacetesseract__common.html#a431ff65777ee0bed71e7671390638244">tesseract_common::TrajArray</a> = typedef Eigen::Matrix&lt;double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a67bde3cb7bb235f0f61c370ef8bc74d8" name="a67bde3cb7bb235f0f61c370ef8bc74d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67bde3cb7bb235f0f61c370ef8bc74d8">&#9670;&#160;</a></span>TransformMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../df/da9/namespacetesseract__common.html#a67bde3cb7bb235f0f61c370ef8bc74d8">tesseract_common::TransformMap</a> = typedef <a class="el" href="../../df/da9/namespacetesseract__common.html#a2c5a4b6149060671cf8c3f9d15ef58c4">AlignedMap</a>&lt;std::string, Eigen::Isometry3d&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a94d9921fc7ed323609ac57d06f939cb6" name="a94d9921fc7ed323609ac57d06f939cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d9921fc7ed323609ac57d06f939cb6">&#9670;&#160;</a></span>VectorIsometry3d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../df/da9/namespacetesseract__common.html#a94d9921fc7ed323609ac57d06f939cb6">tesseract_common::VectorIsometry3d</a> = typedef <a class="el" href="../../df/da9/namespacetesseract__common.html#a000d15c3ab8d8ba4ebdaae64153b053a">AlignedVector</a>&lt;Eigen::Isometry3d&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac60e1af30f961fc086b69e330c6434d4" name="ac60e1af30f961fc086b69e330c6434d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60e1af30f961fc086b69e330c6434d4">&#9670;&#160;</a></span>VectorVector2d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../df/da9/namespacetesseract__common.html#ac60e1af30f961fc086b69e330c6434d4">tesseract_common::VectorVector2d</a> = typedef <a class="el" href="../../df/da9/namespacetesseract__common.html#a000d15c3ab8d8ba4ebdaae64153b053a">AlignedVector</a>&lt;Eigen::Vector2d&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af89ed6517f4c84bdb2b037bb40f7d9d9" name="af89ed6517f4c84bdb2b037bb40f7d9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af89ed6517f4c84bdb2b037bb40f7d9d9">&#9670;&#160;</a></span>VectorVector3d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../df/da9/namespacetesseract__common.html#af89ed6517f4c84bdb2b037bb40f7d9d9">tesseract_common::VectorVector3d</a> = typedef std::vector&lt;Eigen::Vector3d&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f208ea8b9c62f41c593647319d56f37" name="a7f208ea8b9c62f41c593647319d56f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f208ea8b9c62f41c593647319d56f37">&#9670;&#160;</a></span>VectorVector4d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../df/da9/namespacetesseract__common.html#a7f208ea8b9c62f41c593647319d56f37">tesseract_common::VectorVector4d</a> = typedef <a class="el" href="../../df/da9/namespacetesseract__common.html#a000d15c3ab8d8ba4ebdaae64153b053a">AlignedVector</a>&lt;Eigen::Vector4d&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="af06d85d024a36d63b58a6031556af8a1" name="af06d85d024a36d63b58a6031556af8a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af06d85d024a36d63b58a6031556af8a1">&#9670;&#160;</a></span>CollisionMarginOverrideType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="../../df/da9/namespacetesseract__common.html#af06d85d024a36d63b58a6031556af8a1">tesseract_common::CollisionMarginOverrideType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identifies how the provided contact margin data should be applied. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af06d85d024a36d63b58a6031556af8a1ab50339a10e1de285ac99d4c3990b8693" name="af06d85d024a36d63b58a6031556af8a1ab50339a10e1de285ac99d4c3990b8693"></a>NONE&#160;</td><td class="fielddoc"><p >Do not apply contact margin data. </p>
</td></tr>
<tr><td class="fieldname"><a id="af06d85d024a36d63b58a6031556af8a1a560a2dd6f6744646473b3b19e1fe96d7" name="af06d85d024a36d63b58a6031556af8a1a560a2dd6f6744646473b3b19e1fe96d7"></a>REPLACE&#160;</td><td class="fielddoc"><p >Replace the contact manager's <a class="el" href="../../d6/dc7/classtesseract__common_1_1CollisionMarginData.html" title="Stores information about how the margins allowed between collision objects.">CollisionMarginData</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="af06d85d024a36d63b58a6031556af8a1ab9f20f7748e2e578e81ea9ae1a0dfb30" name="af06d85d024a36d63b58a6031556af8a1ab9f20f7748e2e578e81ea9ae1a0dfb30"></a>MODIFY&#160;</td><td class="fielddoc"><p >Modify the contact managers default margin and pair margins. </p>
<p >This will preserve existing pairs not being modified by the provided margin data. If a pair already exist it will be updated with the provided margin data. </p>
</td></tr>
<tr><td class="fieldname"><a id="af06d85d024a36d63b58a6031556af8a1a68f2f4f7ee420d8895a41ac3f35db3fe" name="af06d85d024a36d63b58a6031556af8a1a68f2f4f7ee420d8895a41ac3f35db3fe"></a>OVERRIDE_DEFAULT_MARGIN&#160;</td><td class="fielddoc"><p >Override the contact managers default margin only. </p>
</td></tr>
<tr><td class="fieldname"><a id="af06d85d024a36d63b58a6031556af8a1ae54086ed48f7d2ca425bdeca2121c83c" name="af06d85d024a36d63b58a6031556af8a1ae54086ed48f7d2ca425bdeca2121c83c"></a>OVERRIDE_PAIR_MARGIN&#160;</td><td class="fielddoc"><p >Override the contact managers pair margin only. This does not preserve any existing pair margin data. </p>
</td></tr>
<tr><td class="fieldname"><a id="af06d85d024a36d63b58a6031556af8a1a8f7ea9e9137c5d7d8bc6ea025484f55a" name="af06d85d024a36d63b58a6031556af8a1a8f7ea9e9137c5d7d8bc6ea025484f55a"></a>MODIFY_PAIR_MARGIN&#160;</td><td class="fielddoc"><p >Modify the contact managers pair margin only. </p>
<p >This will preserve existing pairs not being modified by the provided margin data. If a pair already exist it will be updated with the provided margin data. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8eb8b43bdac2751a9a899e4552537cda" name="a8eb8b43bdac2751a9a899e4552537cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb8b43bdac2751a9a899e4552537cda">&#9670;&#160;</a></span>almostEqualRelativeAndAbs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tesseract_common::almostEqualRelativeAndAbs </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_diff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_rel_diff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two Eigen VectorXd are relatively and absolute equal. </p>
<p >This is a vectorized implementation of the function above. The max_diff is for handling when comparing numbers near zero </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A vector of double </td></tr>
    <tr><td class="paramname">b</td><td>A vector of double </td></tr>
    <tr><td class="paramname">max_diff</td><td>The max diff when comparing max(abs(a - b)) &lt;= max_diff, if true they are considered equal </td></tr>
    <tr><td class="paramname">max_rel_diff</td><td>The max relative diff abs(a - b) &lt;= largest * max_rel_diff, if true considered equal. The largest is the largest of the absolute values of a and b. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if they are relatively equal, otherwise false. </dd></dl>

</div>
</div>
<a id="a12eb899ec3967699e946431730eed959" name="a12eb899ec3967699e946431730eed959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12eb899ec3967699e946431730eed959">&#9670;&#160;</a></span>almostEqualRelativeAndAbs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tesseract_common::almostEqualRelativeAndAbs </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_diff</em> = <code>1e-6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_rel_diff</em> = <code>std::numeric_limits&lt;double&gt;::epsilon()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two Eigen VectorXd are relatively and absolute equal. </p>
<p >This is a vectorized implementation of the function above. The max_diff is for handling when comparing numbers near zero </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A vector of double </td></tr>
    <tr><td class="paramname">b</td><td>A vector of double </td></tr>
    <tr><td class="paramname">max_diff</td><td>The max diff when comparing max(abs(a - b)) &lt;= max_diff, if true they are considered equal </td></tr>
    <tr><td class="paramname">max_rel_diff</td><td>The max relative diff abs(a - b) &lt;= largest * max_rel_diff, if true considered equal. The largest is the largest of the absolute values of a and b. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if they are relatively equal, otherwise false. </dd></dl>

</div>
</div>
<a id="ac9961ff2a5d322165a817241b7746f64" name="ac9961ff2a5d322165a817241b7746f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9961ff2a5d322165a817241b7746f64">&#9670;&#160;</a></span>almostEqualRelativeAndAbs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tesseract_common::almostEqualRelativeAndAbs </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_diff</em> = <code>1e-6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_rel_diff</em> = <code>std::numeric_limits&lt;double&gt;::epsilon()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two double are relatively equal. </p>
<p >The max_diff is for handling when comparing numbers near zero </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Double </td></tr>
    <tr><td class="paramname">b</td><td>Double </td></tr>
    <tr><td class="paramname">max_diff</td><td>The max diff when comparing std::abs(a - b) &lt;= max_diff, if true they are considered equal </td></tr>
    <tr><td class="paramname">max_rel_diff</td><td>The max relative diff std::abs(a - b) &lt;= largest * max_rel_diff, if true considered equal. The largest is the largest of the absolute values of a and b. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if they are relatively equal, otherwise false. </dd></dl>

</div>
</div>
<a id="a715e8a56239e73ccfa00e82cda79a28c" name="a715e8a56239e73ccfa00e82cda79a28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715e8a56239e73ccfa00e82cda79a28c">&#9670;&#160;</a></span>calcRotationalError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d tesseract_common::calcRotationalError </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the rotation error vector given a rotation error matrix where the angle is between [-pi, pi]. </p>
<p >This should be used only for calculating the error. Do not use for numerically calculating jacobians because it breaks down a -PI and PI </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>rotation error matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rotation error vector = Eigen::AngleAxisd.axis() * Eigen::AngleAxisd.angle() </dd></dl>

</div>
</div>
<a id="a41a6314e5371fa9604c459b85f159afd" name="a41a6314e5371fa9604c459b85f159afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a6314e5371fa9604c459b85f159afd">&#9670;&#160;</a></span>calcRotationalError2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d tesseract_common::calcRotationalError2 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the rotation error vector given a rotation error matrix where the angle is between [0, 2 * pi]. </p>
<p >This function does not break down when the angle is near zero or 2pi when calculating the numerical jacobian. This is because when using Eigen's angle axis it converts the angle to be between [0, PI] where internally if the angle is between [-PI, 0] it flips the sign of the axis. Both this function and calcRotationalError both check for this flip and reverts it. Since the angle is always between [-PI, PI], switching the range to [0, PI] will never be close to 2PI. In the case of zero, it also does not break down because we are making sure that the angle axis aligns with the quaternion axis eliminating this issue. As you can see the quaternion keeps the angle small but flips the axis so the correct delta rotation is calculated.</p>
<p >Angle: 0.001 results in an axis: [0, 0, 1] Angle: -0.001 results in and axis: [0, 0, -1] e1 = angle * axis = [0, 0, 0.001] e2 = angle * axis = [0, 0, -0.001] delta = e2 - e1 = [0, 0, 0.002]</p>
<p >This should be used when numerically calculating rotation jacobians </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>rotation error matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rotation error vector = Eigen::AngleAxisd.axis() * Eigen::AngleAxisd.angle() </dd></dl>

</div>
</div>
<a id="a913b8ec499e3bfe779dc95bae54f39d4" name="a913b8ec499e3bfe779dc95bae54f39d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913b8ec499e3bfe779dc95bae54f39d4">&#9670;&#160;</a></span>calcTransformError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd tesseract_common::calcTransformError </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Isometry3d &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Isometry3d &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate error between two transforms expressed in t1 coordinate system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>Target Transform </td></tr>
    <tr><td class="paramname">t2</td><td>Current Transform </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error [Position, Rotational(Angle Axis)] </dd></dl>

</div>
</div>
<a id="a631a653d4a106106694065f7b88ede26" name="a631a653d4a106106694065f7b88ede26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631a653d4a106106694065f7b88ede26">&#9670;&#160;</a></span>compareYAML()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tesseract_common::compareYAML </td>
          <td>(</td>
          <td class="paramtype">const YAML::Node &amp;&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const YAML::Node &amp;&#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the YAML::Nodes are identical. </p>
<p >The == operator checks if they reference the same memory. This checks if they contain the same information </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node1</td><td>Input YAML::Node </td></tr>
    <tr><td class="paramname">node2</td><td>Input YAML::Node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d105162c2cd10693e7387cb74d8318b" name="a0d105162c2cd10693e7387cb74d8318b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d105162c2cd10693e7387cb74d8318b">&#9670;&#160;</a></span>computeRandomColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector4d tesseract_common::computeRandomColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This computes a random color RGBA [0, 1] with alpha set to 1. </p>
<dl class="section return"><dt>Returns</dt><dd>A random RGBA color </dd></dl>

</div>
</div>
<a id="a757f1e4610f79b4e79e796c698a3c113" name="a757f1e4610f79b4e79e796c698a3c113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757f1e4610f79b4e79e796c698a3c113">&#9670;&#160;</a></span>concat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd tesseract_common::concat </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two vector. </p>

</div>
</div>
<a id="a1b11bad846aa502a484a8586f78c2a09" name="a1b11bad846aa502a484a8586f78c2a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b11bad846aa502a484a8586f78c2a09">&#9670;&#160;</a></span>enforcePositionLimits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tesseract_common::enforcePositionLimits </td>
          <td>(</td>
          <td class="paramtype">Eigen::Ref&lt; Eigen::Matrix&lt; FloatType, Eigen::Dynamic, 1 &gt; &gt;&#160;</td>
          <td class="paramname"><em>joint_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; FloatType, Eigen::Dynamic, 2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>position_limits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enforce position to be within the provided limits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joint_positions</td><td>The joint position to enforce bounds on </td></tr>
    <tr><td class="paramname">joint_limits</td><td>The limits to perform check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f8d20fecfeb1e99cc55d316977c3f3d" name="a1f8d20fecfeb1e99cc55d316977c3f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8d20fecfeb1e99cc55d316977c3f3d">&#9670;&#160;</a></span>enforcePositionLimits&lt; double &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="../../df/da9/namespacetesseract__common.html#a1b11bad846aa502a484a8586f78c2a09">tesseract_common::enforcePositionLimits</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">Eigen::Ref&lt; Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &gt;&#160;</td>
          <td class="paramname"><em>joint_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; double, Eigen::Dynamic, 2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>position_limits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2df6f30957cf5c867be9ca71aa24e1ab" name="a2df6f30957cf5c867be9ca71aa24e1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df6f30957cf5c867be9ca71aa24e1ab">&#9670;&#160;</a></span>enforcePositionLimits&lt; float &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="../../df/da9/namespacetesseract__common.html#a1b11bad846aa502a484a8586f78c2a09">tesseract_common::enforcePositionLimits</a>&lt; float &gt; </td>
          <td>(</td>
          <td class="paramtype">Eigen::Ref&lt; Eigen::Matrix&lt; float, Eigen::Dynamic, 1 &gt; &gt;&#160;</td>
          <td class="paramname"><em>joint_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; float, Eigen::Dynamic, 2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>position_limits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad10d68b681f3d352a15736ffef688010" name="ad10d68b681f3d352a15736ffef688010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10d68b681f3d352a15736ffef688010">&#9670;&#160;</a></span>extractLibrariesWithFullPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::string &gt; tesseract_common::extractLibrariesWithFullPath </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>library_names</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This will remove libraries with full path in the provided library_names and return them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">library_names</td><td>The set to search and remove libraries with full paths </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of the libraries provided as full path </dd></dl>

</div>
</div>
<a id="aca142577b0d587606411468a2163106f" name="aca142577b0d587606411468a2163106f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca142577b0d587606411468a2163106f">&#9670;&#160;</a></span>fileToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tesseract_common::fileToString </td>
          <td>(</td>
          <td class="paramtype">const tesseract_common::fs::path &amp;&#160;</td>
          <td class="paramname"><em>filepath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read in the contents of the file into a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filepath</td><td>The file to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contents of the file </dd></dl>

</div>
</div>
<a id="ac8f354484775381dd5c207ee0dfe21f2" name="ac8f354484775381dd5c207ee0dfe21f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f354484775381dd5c207ee0dfe21f2">&#9670;&#160;</a></span>fromYAMLString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">YAML::Node tesseract_common::fromYAMLString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts yaml string to a YAML::Node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>Input string containing the yaml </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Resulting YAML::Node </dd></dl>

</div>
</div>
<a id="aa14552337385ce1de42da699506f8b03" name="aa14552337385ce1de42da699506f8b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14552337385ce1de42da699506f8b03">&#9670;&#160;</a></span>generateRandomNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd tesseract_common::generateRandomNumber </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixX2d &gt; &amp;&#160;</td>
          <td class="paramname"><em>limits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of limits it will generate a vector of random numbers between the limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">limits</td><td>The limits to generated numbers based on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of random numbers between the provided limits. </dd></dl>

</div>
</div>
<a id="aaca6ae7b6cbd8d28ad6e141239a0206f" name="aaca6ae7b6cbd8d28ad6e141239a0206f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca6ae7b6cbd8d28ad6e141239a0206f">&#9670;&#160;</a></span>getAllowedCollisions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; tesseract_common::getAllowedCollisions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>link_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/da9/namespacetesseract__common.html#a79d2a34647d0da5e574629878c142086">AllowedCollisionEntries</a> &amp;&#160;</td>
          <td class="paramname"><em>acm_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_duplicates</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets allowed collisions for a set of link names. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_names</td><td>Vector of link names for which we want the allowed collisions </td></tr>
    <tr><td class="paramname">acm_entries</td><td>Entries in the ACM. Get this with <a class="el" href="../../d7/d4e/classtesseract__common_1_1AllowedCollisionMatrix.html#a7bb1745d0489667875d48df2733cb13e" title="Get all of the entries in the allowed collision matrix.">AllowedCollisionMatrix::getAllAllowedCollisions()</a> </td></tr>
    <tr><td class="paramname">remove_duplicates</td><td>If true, duplicates will be removed. Default: true </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of links that are allowed to collide with links given </dd></dl>

</div>
</div>
<a id="a6649a8ac1b3dcd569656074bbcfce030" name="a6649a8ac1b3dcd569656074bbcfce030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6649a8ac1b3dcd569656074bbcfce030">&#9670;&#160;</a></span>getAllSearchLibraries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::string &gt; tesseract_common::getAllSearchLibraries </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>search_libraries_env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>existing_search_libraries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d07851ebdfbd06448599d1c188a2a50" name="a4d07851ebdfbd06448599d1c188a2a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d07851ebdfbd06448599d1c188a2a50">&#9670;&#160;</a></span>getAllSearchPaths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::string &gt; tesseract_common::getAllSearchPaths </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>search_paths_env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>existing_search_paths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a58ecad04db85855fa9e4de21084598ca" name="a58ecad04db85855fa9e4de21084598ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ecad04db85855fa9e4de21084598ca">&#9670;&#160;</a></span>getTempPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tesseract_common::getTempPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the host temp directory path. </p>
<dl class="section return"><dt>Returns</dt><dd>The host temp directory path </dd></dl>

</div>
</div>
<a id="a1077809c98ad8bf5262e426cff6e63a3" name="a1077809c98ad8bf5262e426cff6e63a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1077809c98ad8bf5262e426cff6e63a3">&#9670;&#160;</a></span>getTimestampString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tesseract_common::getTimestampString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Timestamp string. </p>
<dl class="section return"><dt>Returns</dt><dd>Timestamp string </dd></dl>

</div>
</div>
<a id="a34d98b9f0df320e12b9f9686761f5b1e" name="a34d98b9f0df320e12b9f9686761f5b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d98b9f0df320e12b9f9686761f5b1e">&#9670;&#160;</a></span>isIdentical()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool tesseract_common::isIdentical </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ordered</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &amp;, const <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>equal_pred</em> = <code>[](const&#160;<a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a>&amp;&#160;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a78e1cc09f129a731d55ed82bc47956a7">v1</a>,&#160;const&#160;<a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a>&amp;&#160;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a23dd5e7fffd5f8400cbed32a5071f236">v2</a>)&#160;{&#160;return&#160;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a78e1cc09f129a731d55ed82bc47956a7">v1</a>&#160;==&#160;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a23dd5e7fffd5f8400cbed32a5071f236">v2</a>;&#160;}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &amp;, const <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>[](const&#160;<a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a>&amp;&#160;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a78e1cc09f129a731d55ed82bc47956a7">v1</a>,&#160;const&#160;<a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a>&amp;&#160;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a23dd5e7fffd5f8400cbed32a5071f236">v2</a>)&#160;{&#160;return&#160;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a78e1cc09f129a731d55ed82bc47956a7">v1</a>&#160;&lt;&#160;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a23dd5e7fffd5f8400cbed32a5071f236">v2</a>;&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two vector of strings are identical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>Vector strings </td></tr>
    <tr><td class="paramname">vec2</td><td>Vector strings </td></tr>
    <tr><td class="paramname">ordered</td><td>If true order is relavent, othwise if false order is not relavent </td></tr>
    <tr><td class="paramname">equal_pred</td><td>Binary predicate passed into std::equals to determine if an element is equal. Useful for vectors of pointers </td></tr>
    <tr><td class="paramname">comp</td><td>Binary function passed into std::sort. Only used it ordered == false. Useful for vectors of pointers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14e39b554da010e8c36060d6d3683518" name="a14e39b554da010e8c36060d6d3683518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e39b554da010e8c36060d6d3683518">&#9670;&#160;</a></span>isIdentical&lt; Eigen::Index &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template bool <a class="el" href="../../df/da9/namespacetesseract__common.html#a34d98b9f0df320e12b9f9686761f5b1e">tesseract_common::isIdentical</a>&lt; Eigen::Index &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::Index &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Index &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const Eigen::Index &amp;, const Eigen::Index &amp;)&gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const Eigen::Index &amp;, const Eigen::Index &amp;)&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81e6b461e723426fcfde3465ceb4b79d" name="a81e6b461e723426fcfde3465ceb4b79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e6b461e723426fcfde3465ceb4b79d">&#9670;&#160;</a></span>isIdentical&lt; std::string &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template bool <a class="el" href="../../df/da9/namespacetesseract__common.html#a34d98b9f0df320e12b9f9686761f5b1e">tesseract_common::isIdentical</a>&lt; std::string &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const std::string &amp;, const std::string &amp;)&gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const std::string &amp;, const std::string &amp;)&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff7498ab87445e5c870e74a7d3cbc78f" name="aff7498ab87445e5c870e74a7d3cbc78f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff7498ab87445e5c870e74a7d3cbc78f">&#9670;&#160;</a></span>isIdenticalArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , std::size_t Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool tesseract_common::isIdenticalArray </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; ValueType, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>array_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; ValueType, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>array_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const ValueType &amp;, const ValueType &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>value_eq</em> = <code>[](const&#160;ValueType&amp;&#160;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a78e1cc09f129a731d55ed82bc47956a7">v1</a>,&#160;const&#160;ValueType&amp;&#160;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a23dd5e7fffd5f8400cbed32a5071f236">v2</a>)&#160;{&#160;return&#160;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a78e1cc09f129a731d55ed82bc47956a7">v1</a>&#160;==&#160;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a23dd5e7fffd5f8400cbed32a5071f236">v2</a>;&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if 2 arrays are identical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array_1</td><td>First array </td></tr>
    <tr><td class="paramname">array_2</td><td>Second array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if they are identical </dd></dl>

</div>
</div>
<a id="a4be902621fe3d33f5fe7d72116196f24" name="a4be902621fe3d33f5fe7d72116196f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be902621fe3d33f5fe7d72116196f24">&#9670;&#160;</a></span>isIdenticalMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyValueContainerType , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool tesseract_common::isIdenticalMap </td>
          <td>(</td>
          <td class="paramtype">const KeyValueContainerType &amp;&#160;</td>
          <td class="paramname"><em>map_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyValueContainerType &amp;&#160;</td>
          <td class="paramname"><em>map_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const ValueType &amp;, const ValueType &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>value_eq</em> = <code>[](const&#160;ValueType&amp;&#160;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a78e1cc09f129a731d55ed82bc47956a7">v1</a>,&#160;const&#160;ValueType&amp;&#160;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a23dd5e7fffd5f8400cbed32a5071f236">v2</a>)&#160;{&#160;return&#160;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a78e1cc09f129a731d55ed82bc47956a7">v1</a>&#160;==&#160;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a23dd5e7fffd5f8400cbed32a5071f236">v2</a>;&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if 2 maps are identical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map_1</td><td>First map </td></tr>
    <tr><td class="paramname">map_2</td><td>Second map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if they are identical </dd></dl>

</div>
</div>
<a id="a129feb5b5288a992d9fb72ba5dbb579d" name="a129feb5b5288a992d9fb72ba5dbb579d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129feb5b5288a992d9fb72ba5dbb579d">&#9670;&#160;</a></span>isIdenticalSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool tesseract_common::isIdenticalSet </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>set_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>set_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const ValueType &amp;, const ValueType &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>value_eq</em> = <code>[](const&#160;ValueType&amp;&#160;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a78e1cc09f129a731d55ed82bc47956a7">v1</a>,&#160;const&#160;ValueType&amp;&#160;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a23dd5e7fffd5f8400cbed32a5071f236">v2</a>)&#160;{&#160;return&#160;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a78e1cc09f129a731d55ed82bc47956a7">v1</a>&#160;==&#160;<a class="el" href="../../de/df1/tesseract__common__unit_8cpp.html#a23dd5e7fffd5f8400cbed32a5071f236">v2</a>;&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if 2 sets are identical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map_1</td><td>First map </td></tr>
    <tr><td class="paramname">map_2</td><td>Second map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if they are identical </dd></dl>

</div>
</div>
<a id="a1dc3a9525efbe582991edd4eedc26079" name="a1dc3a9525efbe582991edd4eedc26079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc3a9525efbe582991edd4eedc26079">&#9670;&#160;</a></span>isNumeric() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tesseract_common::isNumeric </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a string is a number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to evaluate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if numeric, otherwise false. </dd></dl>

</div>
</div>
<a id="a0db40f06dba7e6be18a2c4f098ad7a00" name="a0db40f06dba7e6be18a2c4f098ad7a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db40f06dba7e6be18a2c4f098ad7a00">&#9670;&#160;</a></span>isNumeric() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tesseract_common::isNumeric </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if each string in vector is a number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The vector of strings to evaluate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all strings are numeric, otherwise false. </dd></dl>

</div>
</div>
<a id="a6cc465537e94a07d22996dd2708f6084" name="a6cc465537e94a07d22996dd2708f6084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc465537e94a07d22996dd2708f6084">&#9670;&#160;</a></span>isWithinPositionLimits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool tesseract_common::isWithinPositionLimits </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; FloatType, Eigen::Dynamic, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>joint_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; FloatType, Eigen::Dynamic, 2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>position_limits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if within position limits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joint_positions</td><td>The joint position to check </td></tr>
    <tr><td class="paramname">position_limits</td><td>The joint limits to perform check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ad39ab29a90ad257cf5418b8eeb77e4af" name="ad39ab29a90ad257cf5418b8eeb77e4af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39ab29a90ad257cf5418b8eeb77e4af">&#9670;&#160;</a></span>isWithinPositionLimits&lt; double &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template bool <a class="el" href="../../df/da9/namespacetesseract__common.html#a6cc465537e94a07d22996dd2708f6084">tesseract_common::isWithinPositionLimits</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>joint_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; double, Eigen::Dynamic, 2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>position_limits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a14ebb17906855938c53c073603e40143" name="a14ebb17906855938c53c073603e40143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ebb17906855938c53c073603e40143">&#9670;&#160;</a></span>isWithinPositionLimits&lt; float &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template bool <a class="el" href="../../df/da9/namespacetesseract__common.html#a6cc465537e94a07d22996dd2708f6084">tesseract_common::isWithinPositionLimits</a>&lt; float &gt; </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; float, Eigen::Dynamic, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>joint_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; float, Eigen::Dynamic, 2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>position_limits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b00920e39050a4b9df5e3100aac7e55" name="a9b00920e39050a4b9df5e3100aac7e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b00920e39050a4b9df5e3100aac7e55">&#9670;&#160;</a></span>jacobianChangeBase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tesseract_common::jacobianChangeBase </td>
          <td>(</td>
          <td class="paramtype">Eigen::Ref&lt; Eigen::MatrixXd &gt;&#160;</td>
          <td class="paramname"><em>jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Isometry3d &amp;&#160;</td>
          <td class="paramname"><em>change_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the base coordinate system of the jacobian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jacobian</td><td>The current Jacobian which gets modified in place </td></tr>
    <tr><td class="paramname">change_base</td><td>The transform from the desired frame to the current base frame of the jacobian </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5043afd3f3dbdd6655d543e09a7c9ea4" name="a5043afd3f3dbdd6655d543e09a7c9ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5043afd3f3dbdd6655d543e09a7c9ea4">&#9670;&#160;</a></span>jacobianChangeRefPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tesseract_common::jacobianChangeRefPoint </td>
          <td>(</td>
          <td class="paramtype">Eigen::Ref&lt; Eigen::MatrixXd &gt;&#160;</td>
          <td class="paramname"><em>jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the reference point of the jacobian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jacobian</td><td>The current Jacobian which gets modified in place </td></tr>
    <tr><td class="paramname">ref_point</td><td>Is expressed in the same base frame of the jacobian and is a vector from the old point to the new point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af46edf9701e45b20e95a5abfac500b8f" name="af46edf9701e45b20e95a5abfac500b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46edf9701e45b20e95a5abfac500b8f">&#9670;&#160;</a></span>ltrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tesseract_common::ltrim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left trim string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to left trim </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11bc9620a27eede3300420410e0b4a7a" name="a11bc9620a27eede3300420410e0b4a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11bc9620a27eede3300420410e0b4a7a">&#9670;&#160;</a></span>makeOrderedLinkPair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/da9/namespacetesseract__common.html#a5b28b7ae665b374a7ca166d496f648ce">LinkNamesPair</a> tesseract_common::makeOrderedLinkPair </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>link_name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>link_name2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pair of strings, where the pair.first is always &lt;= pair.second. </p>
<p >This is commonly used along with <a class="el" href="../../d7/de0/structtesseract__common_1_1PairHash.html">PairHash</a> as the key to an unordered_map&lt;LinkNamesPair, Type, PairHash&gt; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name1</td><td>First link name </td></tr>
    <tr><td class="paramname">link_name2</td><td>Second link name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LinkNamesPair a lexicographically sorted pair of strings </dd></dl>

</div>
</div>
<a id="a713dad4aa33bbdae5fb5aec8e83466e2" name="a713dad4aa33bbdae5fb5aec8e83466e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713dad4aa33bbdae5fb5aec8e83466e2">&#9670;&#160;</a></span>my_rethrow_if_nested() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!std::is_polymorphic&lt; E &gt;<a class="el" href="../../d4/d44/tesseract__common__serialization__unit_8cpp.html#a767de28b215ddaceb31188034a0838c0">::value</a> &gt; tesseract_common::my_rethrow_if_nested </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc1990ddb29716885e94980b49c187d8" name="abc1990ddb29716885e94980b49c187d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1990ddb29716885e94980b49c187d8">&#9670;&#160;</a></span>my_rethrow_if_nested() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_polymorphic&lt; E &gt;<a class="el" href="../../d4/d44/tesseract__common__serialization__unit_8cpp.html#a767de28b215ddaceb31188034a0838c0">::value</a> &gt; tesseract_common::my_rethrow_if_nested </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0808e2d3c913c41e852ab3819eadd828" name="a0808e2d3c913c41e852ab3819eadd828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0808e2d3c913c41e852ab3819eadd828">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tesseract_common::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/da9/namespacetesseract__common.html#a79d2a34647d0da5e574629878c142086">AllowedCollisionEntries</a> &amp;&#160;</td>
          <td class="paramname"><em>entries_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/da9/namespacetesseract__common.html#a79d2a34647d0da5e574629878c142086">AllowedCollisionEntries</a> &amp;&#160;</td>
          <td class="paramname"><em>entries_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2c2ec207efac0e2080c6488163eb082" name="af2c2ec207efac0e2080c6488163eb082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c2ec207efac0e2080c6488163eb082">&#9670;&#160;</a></span>parseEnvironmentVariableList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::string &gt; tesseract_common::parseEnvironmentVariableList </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>env_variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5691a34b0a37453566326959831fb6df" name="a5691a34b0a37453566326959831fb6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5691a34b0a37453566326959831fb6df">&#9670;&#160;</a></span>pointersComparison()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool tesseract_common::pointersComparison </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator for the objects 2 points point to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>First pointer </td></tr>
    <tr><td class="paramname">p2</td><td>Second pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if *p1 &lt; *p2 and neither is nullptr. Non-nullptr is considered &gt; than nullptr </dd></dl>

</div>
</div>
<a id="a65966457329351239c51b09ec1a8d3a4" name="a65966457329351239c51b09ec1a8d3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65966457329351239c51b09ec1a8d3a4">&#9670;&#160;</a></span>pointersEqual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool tesseract_common::pointersEqual </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="../../d7/d07/tesseract__geometry__unit_8cpp.html#a7a165b7657b19d70c1ab512ebd7a7669">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if 2 pointers point to objects that are ==. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>First pointer </td></tr>
    <tr><td class="paramname">p2</td><td>Second pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the objects are == or both pointers are nullptr </dd></dl>

</div>
</div>
<a id="ac4e9558332430365cd69cb2eec1784c8" name="ac4e9558332430365cd69cb2eec1784c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e9558332430365cd69cb2eec1784c8">&#9670;&#160;</a></span>printNestedException()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tesseract_common::printNestedException </td>
          <td>(</td>
          <td class="paramtype">const std::exception &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a nested exception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The exception to print </td></tr>
    <tr><td class="paramname">level</td><td>The exception level which controls the indentation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5ec94b62bea51b6e40598e0f8e7a6c3" name="ab5ec94b62bea51b6e40598e0f8e7a6c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ec94b62bea51b6e40598e0f8e7a6c3">&#9670;&#160;</a></span>QueryDoubleAttributeRequired()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tinyxml2::XMLError tesseract_common::QueryDoubleAttributeRequired </td>
          <td>(</td>
          <td class="paramtype">const tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>xml_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query a double attribute from an xml element and print error log. </p>
<p >This is the same QueryDoubleAttribute but it will print out error messages for the failure conditions so the user only needs to check for the tinyxml2::XML_SUCCESS since it is a required attribute.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xml_element</td><td>The xml attribute to query attribute </td></tr>
    <tr><td class="paramname">name</td><td>The name of the attribute to query </td></tr>
    <tr><td class="paramname">value</td><td>The value to update from the xml attribute </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tinyxml2::XML_SUCCESS if successful, otherwise returns tinyxml2::XML_NO_ATTRIBUTE or tinyxml2::XML_WRONG_ATTRIBUTE_TYPE </dd></dl>

</div>
</div>
<a id="ad9a12946985d34fc3b1fcfb61b473f8b" name="ad9a12946985d34fc3b1fcfb61b473f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a12946985d34fc3b1fcfb61b473f8b">&#9670;&#160;</a></span>QueryIntAttributeRequired()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tinyxml2::XMLError tesseract_common::QueryIntAttributeRequired </td>
          <td>(</td>
          <td class="paramtype">const tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>xml_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query a int attribute from an xml element and print error log. </p>
<p >This is the same QueryIntAttribute but it will print out error messages for the failure conditions so the user only needs to check for the tinyxml2::XML_SUCCESS since it is a required attribute.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xml_element</td><td>The xml attribute to query attribute </td></tr>
    <tr><td class="paramname">name</td><td>The name of the attribute to query </td></tr>
    <tr><td class="paramname">value</td><td>The value to update from the xml attribute </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tinyxml2::XML_SUCCESS if successful, otherwise returns tinyxml2::XML_NO_ATTRIBUTE or tinyxml2::XML_WRONG_ATTRIBUTE_TYPE </dd></dl>

</div>
</div>
<a id="a22a4a1b896230ca84cce7aae2e21673a" name="a22a4a1b896230ca84cce7aae2e21673a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a4a1b896230ca84cce7aae2e21673a">&#9670;&#160;</a></span>QueryStringAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tinyxml2::XMLError tesseract_common::QueryStringAttribute </td>
          <td>(</td>
          <td class="paramtype">const tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>xml_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query a string attribute from an xml element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xml_element</td><td>The xml attribute to query attribute </td></tr>
    <tr><td class="paramname">name</td><td>The name of the attribute to query </td></tr>
    <tr><td class="paramname">value</td><td>The value to update from the xml attribute </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tinyxml2::XML_SUCCESS if successful, otherwise returns tinyxml2::XML_NO_ATTRIBUTE or tinyxml2::XML_WRONG_ATTRIBUTE_TYPE </dd></dl>

</div>
</div>
<a id="a609734264f8b63f5c7815871c40b231f" name="a609734264f8b63f5c7815871c40b231f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609734264f8b63f5c7815871c40b231f">&#9670;&#160;</a></span>QueryStringAttributeRequired()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tinyxml2::XMLError tesseract_common::QueryStringAttributeRequired </td>
          <td>(</td>
          <td class="paramtype">const tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>xml_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query a string attribute from an xml element and print error log. </p>
<p >This is the same QueryStringAttribute but it will print out error messages for the failure conditions so the user only needs to check for the tinyxml2::XML_SUCCESS since it is a required attribute.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xml_element</td><td>The xml attribute to query attribute </td></tr>
    <tr><td class="paramname">name</td><td>The name of the attribute to query </td></tr>
    <tr><td class="paramname">value</td><td>The value to update from the xml attribute </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tinyxml2::XML_SUCCESS if successful, otherwise returns tinyxml2::XML_NO_ATTRIBUTE or tinyxml2::XML_WRONG_ATTRIBUTE_TYPE </dd></dl>

</div>
</div>
<a id="ab95676b5418063a1d7c84fbba4ff1fe0" name="ab95676b5418063a1d7c84fbba4ff1fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab95676b5418063a1d7c84fbba4ff1fe0">&#9670;&#160;</a></span>QueryStringText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tinyxml2::XMLError tesseract_common::QueryStringText </td>
          <td>(</td>
          <td class="paramtype">const tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>xml_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query a string Text from xml element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xml_element</td><td>The xml element to query string from </td></tr>
    <tr><td class="paramname">test</td><td>The value to update from the xml element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tinyxml2::XML_SUCCESS if successful, otherwise returns tinyxml2::XML_NO_ATTRIBUTE </dd></dl>

</div>
</div>
<a id="ad3e6914a612484e89bf86c60198b6cdc" name="ad3e6914a612484e89bf86c60198b6cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e6914a612484e89bf86c60198b6cdc">&#9670;&#160;</a></span>QueryStringValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tinyxml2::XMLError tesseract_common::QueryStringValue </td>
          <td>(</td>
          <td class="paramtype">const tinyxml2::XMLAttribute *&#160;</td>
          <td class="paramname"><em>xml_attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query a string value from xml attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xml_attribute</td><td>The xml attribute to query string from </td></tr>
    <tr><td class="paramname">value</td><td>The value to update from the xml attribute </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tinyxml2::XML_SUCCESS if successful, otherwise returns tinyxml2::XML_WRONG_ATTRIBUTE_TYPE </dd></dl>

</div>
</div>
<a id="ae1a3ebd3610dce6d24cc7569606fd9ab" name="ae1a3ebd3610dce6d24cc7569606fd9ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a3ebd3610dce6d24cc7569606fd9ab">&#9670;&#160;</a></span>QueryStringValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tinyxml2::XMLError tesseract_common::QueryStringValue </td>
          <td>(</td>
          <td class="paramtype">const tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>xml_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query a string value from xml element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xml_element</td><td>The xml element to query string from </td></tr>
    <tr><td class="paramname">value</td><td>The value to update from the xml element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tinyxml2::XML_SUCCESS if successful, otherwise returns tinyxml2::XML_NO_ATTRIBUTE </dd></dl>

</div>
</div>
<a id="a7da14d8e3b6c20175711209343aafe2f" name="a7da14d8e3b6c20175711209343aafe2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da14d8e3b6c20175711209343aafe2f">&#9670;&#160;</a></span>reorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tesseract_common::reorder </td>
          <td>(</td>
          <td class="paramtype">Eigen::Ref&lt; Eigen::VectorXd &gt;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Index &gt;&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder Eigen::VectorXd implace given index list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to reorder </td></tr>
    <tr><td class="paramname">order</td><td>A vector of index which define the new order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa86a4f0e5ca9d2b1f5abc3f34735d85b" name="aa86a4f0e5ca9d2b1f5abc3f34735d85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa86a4f0e5ca9d2b1f5abc3f34735d85b">&#9670;&#160;</a></span>rtrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tesseract_common::rtrim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Right trim string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to right trim </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a538003ce5c67e13e56fd7decc0fd7585" name="a538003ce5c67e13e56fd7decc0fd7585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538003ce5c67e13e56fd7decc0fd7585">&#9670;&#160;</a></span>satisfiesPositionLimits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool tesseract_common::satisfiesPositionLimits </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; FloatType, Eigen::Dynamic, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>joint_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; FloatType, Eigen::Dynamic, 2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>position_limits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; FloatType, Eigen::Dynamic, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_diff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; FloatType, Eigen::Dynamic, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_rel_diff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if joint position is within bounds or relatively equal to a limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joint_positions</td><td>The joint position to check </td></tr>
    <tr><td class="paramname">joint_limits</td><td>The joint limits to perform check </td></tr>
    <tr><td class="paramname">max_diff</td><td>The max diff when comparing position to limit value max(abs(position - limit)) &lt;= max_diff, if true they are considered equal </td></tr>
    <tr><td class="paramname">max_rel_diff</td><td>The max relative diff between position and limit abs(position - limit) &lt;= largest * max_rel_diff, if true considered equal. The largest is the largest of the absolute values of position and limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the all position are within the limits or relatively equal to the limit, otherwise false. </dd></dl>

</div>
</div>
<a id="ad966f78ba21ac22b33b036d94958ff82" name="ad966f78ba21ac22b33b036d94958ff82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad966f78ba21ac22b33b036d94958ff82">&#9670;&#160;</a></span>satisfiesPositionLimits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool tesseract_common::satisfiesPositionLimits </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; FloatType, Eigen::Dynamic, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>joint_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; FloatType, Eigen::Dynamic, 2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>position_limits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatType&#160;</td>
          <td class="paramname"><em>max_diff</em> = <code>static_cast&lt;FloatType&gt;(1e-6)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatType&#160;</td>
          <td class="paramname"><em>max_rel_diff</em> = <code>std::numeric_limits&lt;FloatType&gt;::epsilon()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if joint position is within bounds or relatively equal to a limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joint_positions</td><td>The joint position to check </td></tr>
    <tr><td class="paramname">joint_limits</td><td>The joint limits to perform check </td></tr>
    <tr><td class="paramname">max_diff</td><td>The max diff when comparing position to limit value max(abs(position - limit)) &lt;= max_diff, if true they are considered equal </td></tr>
    <tr><td class="paramname">max_rel_diff</td><td>The max relative diff between position and limit abs(position - limit) &lt;= largest * max_rel_diff, if true considered equal. The largest is the largest of the absolute values of position and limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the all position are within the limits or relatively equal to the limit, otherwise false. </dd></dl>

</div>
</div>
<a id="aecbdd93583ff717604b4fc32b1015b39" name="aecbdd93583ff717604b4fc32b1015b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecbdd93583ff717604b4fc32b1015b39">&#9670;&#160;</a></span>satisfiesPositionLimits&lt; double &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template bool <a class="el" href="../../df/da9/namespacetesseract__common.html#a538003ce5c67e13e56fd7decc0fd7585">tesseract_common::satisfiesPositionLimits</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>joint_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; double, Eigen::Dynamic, 2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>position_limits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_diff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_rel_diff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2357c2476cbb1427a259d1dc1b8c20b6" name="a2357c2476cbb1427a259d1dc1b8c20b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2357c2476cbb1427a259d1dc1b8c20b6">&#9670;&#160;</a></span>satisfiesPositionLimits&lt; double &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template bool <a class="el" href="../../df/da9/namespacetesseract__common.html#a538003ce5c67e13e56fd7decc0fd7585">tesseract_common::satisfiesPositionLimits</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>joint_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; double, Eigen::Dynamic, 2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>position_limits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_diff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_rel_diff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abacf44e7b4b89c7b47c11eaae1296428" name="abacf44e7b4b89c7b47c11eaae1296428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abacf44e7b4b89c7b47c11eaae1296428">&#9670;&#160;</a></span>satisfiesPositionLimits&lt; float &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template bool <a class="el" href="../../df/da9/namespacetesseract__common.html#a538003ce5c67e13e56fd7decc0fd7585">tesseract_common::satisfiesPositionLimits</a>&lt; float &gt; </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; float, Eigen::Dynamic, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>joint_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; float, Eigen::Dynamic, 2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>position_limits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; float, Eigen::Dynamic, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_diff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; float, Eigen::Dynamic, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_rel_diff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a70b4f11e829b5fba3c3d80d5a1f4b6e2" name="a70b4f11e829b5fba3c3d80d5a1f4b6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b4f11e829b5fba3c3d80d5a1f4b6e2">&#9670;&#160;</a></span>satisfiesPositionLimits&lt; float &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template bool <a class="el" href="../../df/da9/namespacetesseract__common.html#a538003ce5c67e13e56fd7decc0fd7585">tesseract_common::satisfiesPositionLimits</a>&lt; float &gt; </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; float, Eigen::Dynamic, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>joint_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix&lt; float, Eigen::Dynamic, 2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>position_limits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_diff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_rel_diff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f13ad2a741226ab5255302f6750ed4a" name="a7f13ad2a741226ab5255302f6750ed4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f13ad2a741226ab5255302f6750ed4a">&#9670;&#160;</a></span>strFormat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string tesseract_common::strFormat </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aadfa4845aecc119ae62b37e59c6ee168" name="aadfa4845aecc119ae62b37e59c6ee168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadfa4845aecc119ae62b37e59c6ee168">&#9670;&#160;</a></span>StringAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tesseract_common::StringAttribute </td>
          <td>(</td>
          <td class="paramtype">const tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>xml_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get string attribute if exist. If it does not exist it returns the default value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xml_element</td><td>The xml element to attempt to parse attribute </td></tr>
    <tr><td class="paramname">name</td><td>The name of the attribute </td></tr>
    <tr><td class="paramname">default_value</td><td>The default value to return if attribute does not exist </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Parsed string attribute or default value if attribute does not exist. </dd></dl>

</div>
</div>
<a id="a5330a58c8c79cce5559a316e76118558" name="a5330a58c8c79cce5559a316e76118558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5330a58c8c79cce5559a316e76118558">&#9670;&#160;</a></span>testSerialization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SerializableType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tesseract_common::testSerialization </td>
          <td>(</td>
          <td class="paramtype">const SerializableType &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>typename_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests Boost serialization for a serializable type. </p>
<p >Serializes the type to XML file, binary file, and XML string. It then deserializes it and calls the equality operator on the results </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>Object to be serialized </td></tr>
    <tr><td class="paramname">typename_string</td><td>Prefix used for filepaths. Serialized files are put in /tmp/&lt;typename_string&gt;.&lt;extension&gt; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8cf5fe962e9933b44d1f8248f0ab2fb" name="aa8cf5fe962e9933b44d1f8248f0ab2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cf5fe962e9933b44d1f8248f0ab2fb">&#9670;&#160;</a></span>testSerializationDerivedClass()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SerializableTypeBase , typename SerializableTypeDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tesseract_common::testSerializationDerivedClass </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; SerializableTypeBase &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>typename_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests Boost serialization for a serializable derived type. </p>
<p >Serializes the type to XML file, binary file, and XML string using the base type. It then deserializes it, casts it to the derived type, and calls the equality operator on the results </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>Base class pointer to the object to be serialized </td></tr>
    <tr><td class="paramname">typename_string</td><td>Prefix used for filepaths. Serialized files are put in /tmp/&lt;typename_string&gt;.&lt;extension&gt; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b449b344d06caa397190a9a82dd507a" name="a1b449b344d06caa397190a9a82dd507a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b449b344d06caa397190a9a82dd507a">&#9670;&#160;</a></span>testSerializationPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SerializableType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tesseract_common::testSerializationPtr </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; SerializableType &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>typename_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests Boost serialization of shared pointer for a serializable type. </p>
<p >Serializes the type to XML file, binary file, and XML string. It then deserializes it and calls the equality operator on the results </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>Object to be serialized </td></tr>
    <tr><td class="paramname">typename_string</td><td>Prefix used for filepaths. Serialized files are put in /tmp/&lt;typename_string&gt;.&lt;extension&gt; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00bc131acfeba0eba8fe7ff7cd944860" name="a00bc131acfeba0eba8fe7ff7cd944860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00bc131acfeba0eba8fe7ff7cd944860">&#9670;&#160;</a></span>toNumeric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool tesseract_common::toNumeric </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string to a numeric value type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to be converted </td></tr>
    <tr><td class="paramname">value</td><td>The value to be loaded with converted string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, otherwise false </dd></dl>

</div>
</div>
<a id="af5ca1a2af32cf2aa20666fabebb01ae3" name="af5ca1a2af32cf2aa20666fabebb01ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ca1a2af32cf2aa20666fabebb01ae3">&#9670;&#160;</a></span>toNumeric&lt; double &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template bool <a class="el" href="../../df/da9/namespacetesseract__common.html#a00bc131acfeba0eba8fe7ff7cd944860">tesseract_common::toNumeric</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa70232725f5f768795d33beb4d783754" name="aa70232725f5f768795d33beb4d783754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70232725f5f768795d33beb4d783754">&#9670;&#160;</a></span>toNumeric&lt; float &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template bool <a class="el" href="../../df/da9/namespacetesseract__common.html#a00bc131acfeba0eba8fe7ff7cd944860">tesseract_common::toNumeric</a>&lt; float &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b9e402f37e71867b838508147b93ba7" name="a0b9e402f37e71867b838508147b93ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b9e402f37e71867b838508147b93ba7">&#9670;&#160;</a></span>toNumeric&lt; int &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template bool <a class="el" href="../../df/da9/namespacetesseract__common.html#a00bc131acfeba0eba8fe7ff7cd944860">tesseract_common::toNumeric</a>&lt; int &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b11049d2f1fe507189aedf890101ce7" name="a4b11049d2f1fe507189aedf890101ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b11049d2f1fe507189aedf890101ce7">&#9670;&#160;</a></span>toNumeric&lt; long &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template bool <a class="el" href="../../df/da9/namespacetesseract__common.html#a00bc131acfeba0eba8fe7ff7cd944860">tesseract_common::toNumeric</a>&lt; long &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a83b13b4e33c343e723310e3b0e1c59e9" name="a83b13b4e33c343e723310e3b0e1c59e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b13b4e33c343e723310e3b0e1c59e9">&#9670;&#160;</a></span>toYAMLString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string tesseract_common::toYAMLString </td>
          <td>(</td>
          <td class="paramtype">const YAML::Node &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a YAML::Node to a yaml string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Input node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String containing the yaml </dd></dl>

</div>
</div>
<a id="aeacd629bcf585286917aafa7b8e603bb" name="aeacd629bcf585286917aafa7b8e603bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeacd629bcf585286917aafa7b8e603bb">&#9670;&#160;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tesseract_common::trim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trim left and right of string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to trim </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98c27df906a6e17d088772d3d1c21a5d" name="a98c27df906a6e17d088772d3d1c21a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c27df906a6e17d088772d3d1c21a5d">&#9670;&#160;</a></span>twistChangeBase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tesseract_common::twistChangeBase </td>
          <td>(</td>
          <td class="paramtype">Eigen::Ref&lt; Eigen::VectorXd &gt;&#160;</td>
          <td class="paramname"><em>twist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Isometry3d &amp;&#160;</td>
          <td class="paramname"><em>change_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the base coordinate system of the Twist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">twist</td><td>The current Twist which gets modified in place </td></tr>
    <tr><td class="paramname">change_base</td><td>The transform from the desired frame to the current base frame of the Twist </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ed12ea384452e2d5d4f7a0854035384" name="a4ed12ea384452e2d5d4f7a0854035384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed12ea384452e2d5d4f7a0854035384">&#9670;&#160;</a></span>twistChangeRefPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tesseract_common::twistChangeRefPoint </td>
          <td>(</td>
          <td class="paramtype">Eigen::Ref&lt; Eigen::VectorXd &gt;&#160;</td>
          <td class="paramname"><em>twist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the reference point of the provided Twist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">twist</td><td>The current Twist which gets modified in place </td></tr>
    <tr><td class="paramname">ref_point</td><td>Is expressed in the same base frame of the Twist and is a vector from the old point to the new point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aef65970d6ccc97d88621f27e7c35b32a" name="aef65970d6ccc97d88621f27e7c35b32a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef65970d6ccc97d88621f27e7c35b32a">&#9670;&#160;</a></span>mersenne</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mt19937 tesseract_common::mersenne { static_cast&lt;std::mt19937::result_type&gt;(std::time(nullptr)) }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random number generator. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 21 2023 22:03:21 for Tesseract by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
